<!DOCTYPE html>
<html><head>
    <meta charset="utf-8"/>
    <meta content="chrome=1" http-equiv="X-UA-Compatible"/>
    <title>YouCompleteMe by Valloric</title>
    <link href="stylesheets/styles.css" rel="stylesheet"/>
    <link href="stylesheets/pygment_trac.css" rel="stylesheet"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>

  </head>
  <body>
    <div class="wrapper">

      <section>
        <div id="title">
          <h1>YouCompleteMe</h1>
          <p>A code-completion engine for Vim</p>
          <hr/>
          <span class="credits left">Project maintained by <a href="https://github.com/Valloric">Valloric</a></span>
          <span class="credits right">Hosted on GitHub Pages â€” Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></span>
        </div>
    <div id="markdown-output"><p><a href="https://gitter.im/Valloric/YouCompleteMe"><img alt="Gitter Room" src="https://img.shields.io/gitter/room/Valloric/YouCompleteMe.svg"/></a>
<a href="https://travis-ci.org/Valloric/YouCompleteMe"><img alt="Build Status" src="https://travis-ci.org/Valloric/YouCompleteMe.svg?branch=master"/></a>
<a href="https://ci.appveyor.com/project/Valloric/YouCompleteMe"><img alt="Build status" src="https://ci.appveyor.com/api/projects/status/ag9uqwi8s6btwjd8/branch/master?svg=true"/></a>
<a href="https://codecov.io/gh/Valloric/YouCompleteMe"><img alt="Coverage Status" src="https://codecov.io/gh/Valloric/YouCompleteMe/branch/master/graph/badge.svg"/></a></p><ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#mac-os-x">Mac OS X</a></li>
<li><a href="#ubuntu-linux-x64">Ubuntu Linux x64</a></li>
<li><a href="#fedora-linux-x64">Fedora Linux x64</a></li>
<li><a href="#windows">Windows</a></li>
<li><a href="#freebsdopenbsd">FreeBSD/OpenBSD</a></li>
<li><a href="#full-installation-guide">Full Installation Guide</a></li>
</ul>
</li>
<li><a href="#quick-feature-summary">Quick Feature Summary</a></li>
<li><a href="#user-guide">User Guide</a><ul>
<li><a href="#general-usage">General Usage</a></li>
<li><a href="#client-server-architecture">Client-Server Architecture</a></li>
<li><a href="#completion-string-ranking">Completion String Ranking</a></li>
<li><a href="#general-semantic-completion">General Semantic Completion</a></li>
<li><a href="#c-family-semantic-completion">C-family Semantic Completion</a></li>
<li><a href="#javascript-semantic-completion">JavaScript Semantic Completion</a></li>
<li><a href="#rust-semantic-completion">Rust Semantic Completion</a></li>
<li><a href="#python-semantic-completion">Python Semantic Completion</a></li>
<li><a href="#semantic-completion-for-other-languages">Semantic Completion for Other Languages</a></li>
<li><a href="#writing-new-semantic-completers">Writing New Semantic Completers</a></li>
<li><a href="#diagnostic-display">Diagnostic Display</a><ul>
<li><a href="#diagnostic-highlighting-groups">Diagnostic Highlighting Groups</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#commands">Commands</a><ul>
<li><a href="#ycmcompleter-subcommands">YcmCompleter subcommands</a><ul>
<li><a href="#goto-commands">GoTo Commands</a></li>
<li><a href="#semantic-information-commands">Semantic Information Commands</a></li>
<li><a href="#refactoring-and-fixit-commands">Refactoring and FixIt Commands</a></li>
<li><a href="#miscellaneous-commands">Miscellaneous Commands</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#functions">Functions</a></li>
<li><a href="#autocommands">Autocommands</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#faq">FAQ</a></li>
<li><a href="#contributor-code-of-conduct">Contributor Code of Conduct</a></li>
<li><a href="#contact">Contact</a></li>
<li><a href="#license">License</a></li>
</ul><h2 id="intro">Intro</h2><p>YouCompleteMe is a fast, as-you-type, fuzzy-search code completion engine for
<a href="http://www.vim.org/">Vim</a>. It has several completion engines:</p><ul>
<li>an identifier-based engine that works with every programming language,</li>
<li>a <a href="http://clang.llvm.org/">Clang</a>-based engine that provides native semantic code
  completion for C/C++/Objective-C/Objective-C++ (from now on referred to as
  "the C-family languages"),</li>
<li>a <a href="https://github.com/davidhalter/jedi">Jedi</a>-based completion engine for Python 2 and 3 (using the <a href="https://github.com/vheon/JediHTTP">JediHTTP</a> wrapper),</li>
<li>an <a href="https://github.com/OmniSharp/omnisharp-server">OmniSharp</a>-based completion engine for C#,</li>
<li>a combination of <a href="https://github.com/nsf/gocode">Gocode</a> and <a href="https://github.com/Manishearth/godef">Godef</a> semantic engines for Go,</li>
<li>a <a href="https://github.com/Microsoft/TypeScript/tree/master/src/server">TSServer</a>-based completion engine for TypeScript,</li>
<li>a <a href="http://ternjs.net">Tern</a>-based completion engine for JavaScript,</li>
<li>a <a href="https://github.com/phildawes/racer">racer</a>-based completion engine for Rust,</li>
<li>and an omnifunc-based completer that uses data from Vim's omnicomplete system
  to provide semantic completions for many other languages (Ruby, PHP etc.).</li>
</ul><p><img alt="YouCompleteMe GIF demo" src="http://i.imgur.com/0OP4ood.gif"/></p><p>Here's an explanation of what happens in the short GIF demo above.</p><p>First, realize that <strong>no keyboard shortcuts had to be pressed</strong> to get the list
of completion candidates at any point in the demo. The user just types and the
suggestions pop up by themselves. If the user doesn't find the completion
suggestions relevant and/or just wants to type, they can do so; the completion
engine will not interfere.</p><p>When the user sees a useful completion string being offered, they press the TAB
key to accept it. This inserts the completion string. Repeated presses of the
TAB key cycle through the offered completions.</p><p>If the offered completions are not relevant enough, the user can continue typing
to further filter out unwanted completions.</p><p>A critical thing to notice is that the completion <strong>filtering is NOT based on
the input being a string prefix of the completion</strong> (but that works too). The
input needs to be a <em><a href="https://en.wikipedia.org/wiki/Subsequence">subsequence</a> match</em> of a completion. This is a fancy way
of saying that any input characters need to be present in a completion string in
the order in which they appear in the input. So <code>abc</code> is a subsequence of
<code>xaybgc</code>, but not of <code>xbyxaxxc</code>. After the filter, a complicated sorting system
ranks the completion strings so that the most relevant ones rise to the top of
the menu (so you usually need to press TAB just once).</p><p><strong>All of the above works with any programming language</strong> because of the
identifier-based completion engine. It collects all of the identifiers in the
current file and other files you visit (and your tags files) and searches them
when you type (identifiers are put into per-filetype groups).</p><p>The demo also shows the semantic engine in use. When the user presses <code>.</code>, <code>-&gt;</code>
or <code>::</code> while typing in insert mode (for C++; different triggers are used for
other languages), the semantic engine is triggered (it can also be triggered
with a keyboard shortcut; see the rest of the docs).</p><p>The last thing that you can see in the demo is YCM's diagnostic display features
(the little red X that shows up in the left gutter; inspired by <a href="https://github.com/scrooloose/syntastic">Syntastic</a>)
if you are editing a C-family file. As Clang compiles your file and detects
warnings or errors, they will be presented in various ways. You don't need to
save your file or press any keyboard shortcut to trigger this, it "just happens"
in the background.</p><p>In essence, YCM obsoletes the following Vim plugins because it has all of their
features plus extra:</p><ul>
<li>clang_complete</li>
<li>AutoComplPop</li>
<li>Supertab</li>
<li>neocomplcache</li>
</ul><p><strong>And that's not all...</strong></p><p>YCM also provides <a href="#quick-feature-summary">semantic IDE-like features</a> in a
number of languages, including:</p><ul>
<li>finding declarations, definitions, usages, etc. of identifiers,</li>
<li>displaying type information for classes, variables, functions etc.,</li>
<li>displaying documentation for methods, members, etc. in the preview window,</li>
<li>fixing common coding errors, like missing semi-colons, typos, etc.,</li>
<li>semantic renaming of variables across files (JavaScript only).</li>
</ul><p>Features vary by file type, so make sure to check out the <a href="#quick-feature-summary">file type feature
summary</a> and the
<a href="#ycmcompleter-subcommands">full list of completer subcommands</a> to
find out what's available for your favourite languages.</p><p>You'll also find that YCM has filepath completers (try typing <code>./</code> in a file)
and a completer that integrates with <a href="https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt">UltiSnips</a>.</p><h2 id="installation">Installation</h2><h3 id="mac-os-x">Mac OS X</h3><p>These instructions (using <code>install.py</code>) are the quickest way to install
YouCompleteMe, however they may not work for everyone. If the following
instructions don't work for you, check out the <a href="#full-installation-guide">full installation
guide</a>.</p><p>Install the latest version of <a href="https://github.com/macvim-dev/macvim/releases">MacVim</a>. Yes, MacVim. And yes, the <em>latest</em>.</p><p>If you don't use the MacVim GUI, it is recommended to use the Vim binary that is
inside the MacVim.app package (<code>MacVim.app/Contents/MacOS/Vim</code>). To ensure it
works correctly copy the <code>mvim</code> script from the <a href="https://github.com/macvim-dev/macvim/releases">MacVim</a> download to your
local binary folder (for example <code>/usr/local/bin/mvim</code>) and then symlink it:</p><pre><code>ln -s /usr/local/bin/mvim vim
</code></pre><p>Install YouCompleteMe with <a href="https://github.com/VundleVim/Vundle.vim#about">Vundle</a>.</p><p><strong>Remember:</strong> YCM is a plugin with a compiled component. If you <strong>update</strong> YCM
using Vundle and the ycm_core library APIs have changed (happens
rarely), YCM will notify you to recompile it. You should then rerun the install
process.</p><p><strong>NOTE:</strong> If you want C-family completion, you MUST have the latest Xcode
installed along with the latest Command Line Tools (they are installed
automatically when you run <code>clang</code> for the first time, or manually by running
<code>xcode-select --install</code>)</p><p>Install CMake. Preferably with <a href="http://brew.sh">Homebrew</a>, but here's the <a href="https://cmake.org/download/">stand-alone
CMake installer</a>.</p><p><em>If</em> you have installed a Homebrew Python and/or Homebrew MacVim, see the <em>FAQ</em>
for details.</p><p>Compiling YCM <strong>with</strong> semantic support for C-family languages:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --clang-completer
</code></pre><p>Compiling YCM <strong>without</strong> semantic support for C-family languages:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py
</code></pre><p>The following additional language support options are available:</p><ul>
<li>C# support: install Mono with <a href="http://brew.sh">Homebrew</a> or by downloading the <a href="http://www.mono-project.com/docs/getting-started/install/mac/">Mono Mac
  package</a> and add <code>--omnisharp-completer</code> when calling
  <code>./install.py</code>.</li>
<li>Go support: install <a href="https://golang.org/doc/install">Go</a> and add <code>--gocode-completer</code> when calling
  <code>./install.py</code>.</li>
<li>TypeScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> then install the
  TypeScript SDK with <code>npm install -g typescript</code>.</li>
<li>JavaScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> and add
  <code>--tern-completer</code> when calling <code>./install.py</code>.</li>
<li>Rust support: install <a href="https://www.rust-lang.org/">Rust</a> and add
  <code>--racer-completer</code> when calling <code>./install.py</code>.</li>
</ul><p>To simply compile with everything enabled, there's a <code>--all</code> flag.  So, to
install with all language features, ensure <code>xbuild</code>, <code>go</code>, <code>tsserver</code>, <code>node</code>,
<code>npm</code>, <code>rustc</code>, and <code>cargo</code> tools are installed and in your <code>PATH</code>, then
simply run:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --all
</code></pre><p>That's it. You're done. Refer to the <em>User Guide</em> section on how to use YCM.
Don't forget that if you want the C-family semantic completion engine to work,
you will need to provide the compilation flags for your project to YCM. It's all
in the User Guide.</p><p>YCM comes with sane defaults for its options, but you still may want to take a
look at what's available for configuration. There are a few interesting options
that are conservatively turned off by default that you may want to turn on.</p><h3 id="ubuntu-linux-x64">Ubuntu Linux x64</h3><p>These instructions (using <code>install.py</code>) are the quickest way to install
YouCompleteMe, however they may not work for everyone. If the following
instructions don't work for you, check out the <a href="#full-installation-guide">full installation
guide</a>.</p><p>Make sure you have Vim 7.4.143 with Python 2 or Python 3 support. Ubuntu 14.10
and later have a Vim that's recent enough. You can see the version of Vim
installed by running <code>vim --version</code>. If the version is too old, you may need to
<a href="https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source">compile Vim from source</a> (don't worry, it's easy).</p><p>Install YouCompleteMe with <a href="https://github.com/VundleVim/Vundle.vim#about">Vundle</a>.</p><p><strong>Remember:</strong> YCM is a plugin with a compiled component. If you <strong>update</strong> YCM
using Vundle and the ycm_core library APIs have changed (happens
rarely), YCM will notify you to recompile it. You should then rerun the install
process.</p><p>Install development tools and CMake: </p><pre><code>sudo apt-get install build-essential cmake
</code></pre><p>Make sure you have Python headers installed:</p><pre><code>sudo apt-get install python-dev python3-dev
</code></pre><p>Compiling YCM <strong>with</strong> semantic support for C-family languages:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --clang-completer
</code></pre><p>Compiling YCM <strong>without</strong> semantic support for C-family languages:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py
</code></pre><p>The following additional language support options are available:</p><ul>
<li>C# support: install <a href="http://www.mono-project.com/docs/getting-started/install/linux/#debian-ubuntu-and-derivatives">Mono</a> and add <code>--omnisharp-completer</code>
  when calling <code>./install.py</code>.</li>
<li>Go support: install <a href="https://golang.org/doc/install">Go</a> and add <code>--gocode-completer</code> when calling
  <code>./install.py</code>.</li>
<li>TypeScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> then install the
  TypeScript SDK with <code>npm install -g typescript</code>.</li>
<li>JavaScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> and add
  <code>--tern-completer</code> when calling <code>./install.py</code>.</li>
<li>Rust support: install <a href="https://www.rust-lang.org/">Rust</a> and add <code>--racer-completer</code> when
  calling <code>./install.py</code>.</li>
</ul><p>To simply compile with everything enabled, there's a <code>--all</code> flag.  So, to
install with all language features, ensure <code>xbuild</code>, <code>go</code>, <code>tsserver</code>, <code>node</code>,
<code>npm</code>, <code>rustc</code>, and <code>cargo</code> tools are installed and in your <code>PATH</code>, then
simply run:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --all
</code></pre><p>That's it. You're done. Refer to the <em>User Guide</em> section on how to use YCM.
Don't forget that if you want the C-family semantic completion engine to work,
you will need to provide the compilation flags for your project to YCM. It's all
in the User Guide.</p><p>YCM comes with sane defaults for its options, but you still may want to take a
look at what's available for configuration. There are a few interesting options
that are conservatively turned off by default that you may want to turn on.</p><h3 id="fedora-linux-x64">Fedora Linux x64</h3><p>These instructions (using <code>install.py</code>) are the quickest way to install
YouCompleteMe, however they may not work for everyone. If the following
instructions don't work for you, check out the <a href="#full-installation-guide">full installation
guide</a>.</p><p>Make sure you have Vim 7.4.143 with Python 2 or Python 3 support. Fedora 21 and
later have a Vim that's recent enough. You can see the version of Vim installed
by running <code>vim --version</code>. If the version is too old, you may need to <a href="https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source">compile
Vim from source</a> (don't worry, it's easy).</p><p>Install YouCompleteMe with <a href="https://github.com/VundleVim/Vundle.vim#about">Vundle</a>.</p><p><strong>Remember:</strong> YCM is a plugin with a compiled component. If you <strong>update</strong> YCM
using Vundle and the ycm_core library APIs have changed (happens
rarely), YCM will notify you to recompile it. You should then rerun the install
process.</p><p>Install development tools and CMake:</p><pre><code>sudo dnf install automake gcc gcc-c++ kernel-devel cmake
</code></pre><p>Make sure you have Python headers installed:</p><pre><code>sudo dnf install python-devel python3-devel
</code></pre><p>Compiling YCM <strong>with</strong> semantic support for C-family languages:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --clang-completer
</code></pre><p>Compiling YCM <strong>without</strong> semantic support for C-family languages:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py
</code></pre><p>The following additional language support options are available:</p><ul>
<li>C# support: install <a href="http://www.mono-project.com/docs/getting-started/install/linux/#centos-7-fedora-19-and-later-and-derivatives">Mono</a> and add <code>--omnisharp-completer</code>
  when calling <code>./install.py</code>.</li>
<li>Go support: install <a href="https://golang.org/doc/install">Go</a> and add <code>--gocode-completer</code> when calling
  <code>./install.py</code>.</li>
<li>TypeScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> then install the
  TypeScript SDK with <code>npm install -g typescript</code>.</li>
<li>JavaScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> and add
  <code>--tern-completer</code> when calling <code>./install.py</code>.</li>
<li>Rust support: install <a href="https://www.rust-lang.org/">Rust</a> and add <code>--racer-completer</code> when
  calling <code>./install.py</code>.</li>
</ul><p>To simply compile with everything enabled, there's a <code>--all</code> flag.  So, to
install with all language features, ensure <code>xbuild</code>, <code>go</code>, <code>tsserver</code>, <code>node</code>,
<code>npm</code>, <code>rustc</code>, and <code>cargo</code> tools are installed and in your <code>PATH</code>, then
simply run:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --all
</code></pre><p>That's it. You're done. Refer to the <em>User Guide</em> section on how to use YCM.
Don't forget that if you want the C-family semantic completion engine to work,
you will need to provide the compilation flags for your project to YCM. It's all
in the User Guide.</p><p>YCM comes with sane defaults for its options, but you still may want to take a
look at what's available for configuration. There are a few interesting options
that are conservatively turned off by default that you may want to turn on.</p><h3 id="windows">Windows</h3><p>These instructions (using <code>install.py</code>) are the quickest way to install
YouCompleteMe, however they may not work for everyone. If the following
instructions don't work for you, check out the <a href="#full-installation-guide">full installation
guide</a>.</p><p><strong>Important:</strong> we assume that you are using the <code>cmd.exe</code> command prompt and
that you know how to add an executable to the PATH environment variable.</p><p>Make sure you have at least Vim 7.4.143 with Python 2 or Python 3 support. You
can check the version and which Python is supported by typing <code>:version</code> inside
Vim. Look at the features included: <code>+python/dyn</code> for Python 2 and
<code>+python3/dyn</code> for Python 3. Take note of the Vim architecture, i.e. 32 or
64-bit. It will be important when choosing the Python installer. We recommend
using a 64-bit client. <a href="https://bintray.com/micbou/generic/vim">Daily updated copies of 32-bit and 64-bit Vim with
Python 2 and Python 3 support</a> are available.</p><p>Install YouCompleteMe with <a href="https://github.com/VundleVim/Vundle.vim#about">Vundle</a>.</p><p><strong>Remember:</strong> YCM is a plugin with a compiled component. If you <strong>update</strong> YCM
using Vundle and the ycm_core library APIs have changed (happens
rarely), YCM will notify you to recompile it. You should then rerun the install
process.</p><p>Download and install the following software:</p><ul>
<li><a href="https://www.python.org/downloads/windows/">Python 2 or Python 3</a>. Be sure to pick the version
corresponding to your Vim architecture. It is <em>Windows x86</em> for a 32-bit Vim and
<em>Windows x86-64</em> for a 64-bit Vim. We recommend installing Python 3.</li>
<li><a href="https://cmake.org/download/">CMake</a>. Add CMake executable to the PATH environment
variable.</li>
<li><a href="https://www.visualstudio.com/downloads/">Visual Studio</a>. Download the community edition.
During setup, select <em>Desktop development with C++</em> in <em>Workloads</em>.</li>
<li><a href="http://www.7-zip.org/download.html">7-zip</a>. Required to build YCM with semantic support for
C-family languages.</li>
</ul><p>Compiling YCM <strong>with</strong> semantic support for C-family languages:</p><pre><code>cd %USERPROFILE%/vimfiles/bundle/YouCompleteMe
install.py --clang-completer
</code></pre><p>Compiling YCM <strong>without</strong> semantic support for C-family languages:</p><pre><code>cd %USERPROFILE%/vimfiles/bundle/YouCompleteMe
install.py
</code></pre><p>The following additional language support options are available:</p><ul>
<li>C# support: add <code>--omnisharp-completer</code> when calling <code>install.py</code>.
  Be sure that <a href="http://stackoverflow.com/questions/6319274/how-do-i-run-msbuild-from-the-command-line-using-windows-sdk-7-1">the build utility <code>msbuild</code> is in your PATH</a>.</li>
<li>Go support: install <a href="https://golang.org/doc/install">Go</a> and add <code>--gocode-completer</code> when calling
  <code>install.py</code>.</li>
<li>TypeScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> then install the
  TypeScript SDK with <code>npm install -g typescript</code>.</li>
<li>JavaScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> and add
  <code>--tern-completer</code> when calling <code>install.py</code>.</li>
<li>Rust support: install <a href="https://www.rust-lang.org/">Rust</a> and add <code>--racer-completer</code> when
  calling <code>install.py</code>.</li>
</ul><p>To simply compile with everything enabled, there's a <code>--all</code> flag.  So, to
install with all language features, ensure <code>msbuild</code>, <code>go</code>, <code>tsserver</code>, <code>node</code>,
<code>npm</code>, and <code>cargo</code> tools are installed and in your <code>PATH</code>, then simply run:</p><pre><code>cd %USERPROFILE%/vimfiles/bundle/YouCompleteMe
python install.py --all
</code></pre><p>You can specify the Microsoft Visual C++ (MSVC) version using the <code>--msvc</code>
option. YCM officially supports MSVC 12 (Visual Studio 2013), 14 (2015), and 15
(2017).</p><p>That's it. You're done. Refer to the <em>User Guide</em> section on how to use YCM.
Don't forget that if you want the C-family semantic completion engine to work,
you will need to provide the compilation flags for your project to YCM. It's all
in the User Guide.</p><p>YCM comes with sane defaults for its options, but you still may want to take a
look at what's available for configuration. There are a few interesting options
that are conservatively turned off by default that you may want to turn on.</p><h3 id="freebsdopenbsd">FreeBSD/OpenBSD</h3><p>These instructions (using <code>install.py</code>) are the quickest way to install
YouCompleteMe, however they may not work for everyone. If the following
instructions don't work for you, check out the <a href="#full-installation-guide">full installation
guide</a>.</p><p><strong>NOTE:</strong> OpenBSD / FreeBSD are not officially supported platforms by YCM.</p><p>Make sure you have Vim 7.4.143 with Python 2 or Python 3 support.</p><p>OpenBSD 5.5 and later have a Vim that's recent enough. You can see the version of
Vim installed by running <code>vim --version</code>.</p><p>FreeBSD 10.x comes with clang compiler but not the libraries needed to install.</p><pre><code>pkg install llvm38 boost-all boost-python-libs clang38
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/llvm38/lib/
</code></pre><p>Install YouCompleteMe with <a href="https://github.com/VundleVim/Vundle.vim#about">Vundle</a>.</p><p><strong>Remember:</strong> YCM is a plugin with a compiled component. If you <strong>update</strong> YCM
using Vundle and the ycm_core library APIs have changed (happens
rarely), YCM will notify you to recompile it. You should then rerun the install
process.</p><p>Install dependencies and CMake: <code>sudo pkg_add llvm boost cmake</code></p><p>Compiling YCM <strong>with</strong> semantic support for C-family languages:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --clang-completer --system-libclang --system-boost
</code></pre><p>Compiling YCM <strong>without</strong> semantic support for C-family languages:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --system-boost
</code></pre><p>The following additional language support options are available:</p><ul>
<li>C# support: install Mono and add <code>--omnisharp-completer</code> when calling
  <code>./install.py</code>.</li>
<li>Go support: install <a href="https://golang.org/doc/install">Go</a> and add <code>--gocode-completer</code> when calling
  <code>./install.py</code>.</li>
<li>TypeScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> then install the
  TypeScript SDK with <code>npm install -g typescript</code>.</li>
<li>JavaScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a> and add
  <code>--tern-completer</code> when calling <code>./install.py</code>.</li>
<li>Rust support: install <a href="https://www.rust-lang.org/">Rust</a> and add <code>--racer-completer</code> when
  calling <code>./install.py</code>.</li>
</ul><p>To simply compile with everything enabled, there's a <code>--all</code> flag.  So, to
install with all language features, ensure <code>xbuild</code>, <code>go</code>, <code>tsserver</code>, <code>node</code>,
<code>npm</code>, and <code>cargo</code> tools are installed and in your <code>PATH</code>, then simply run:</p><pre><code>cd ~/.vim/bundle/YouCompleteMe
./install.py --all
</code></pre><p>That's it. You're done. Refer to the <em>User Guide</em> section on how to use YCM.
Don't forget that if you want the C-family semantic completion engine to work,
you will need to provide the compilation flags for your project to YCM. It's all
in the User Guide.</p><p>YCM comes with sane defaults for its options, but you still may want to take a
look at what's available for configuration. There are a few interesting options
that are conservatively turned off by default that you may want to turn on.</p><h3 id="full-installation-guide">Full Installation Guide</h3><p>These are the steps necessary to get YCM working on a Unix OS and on Windows.</p><p><strong>Note to Windows users:</strong> we assume that you are running the <code>cmd.exe</code> command
prompt and that the needed executables are in the PATH environment variable. Do
not just copy the shell commands. Replace <code>~</code> by <code>%USERPROFILE%</code> in them and use
the right Vim home directory. It should be <code>vimfiles</code> by default instead of
<code>.vim</code>.</p><p>See the <em>FAQ</em> if you have any issues.</p><p><strong>Remember:</strong> YCM is a plugin with a compiled component. If you <strong>update</strong> YCM
using Vundle and the ycm_core library APIs have changed (happens
rarely), YCM will notify you to recompile it. You should then rerun the install
process.</p><p><strong>Please follow the instructions carefully. Read EVERY WORD.</strong></p><ol>
<li>
<p><strong>Ensure that your version of Vim is <em>at least</em> 7.4.143 <em>and</em> that it has
    support for Python 2 or Python 3 scripting</strong>.</p>
<p>Inside Vim, type <code>:version</code>. Look at the first two to three lines of output;
it should say <code>Vi IMproved X.Y</code>, where X.Y is the major version of vim. If
your version is greater than 7.4, then you're all set. If your version is
7.4 then look below that where it says, <code>Included patches: 1-Z</code>, where Z
will be some number. That number needs to be 143 or higher.</p>
<p>If your version of Vim is not recent enough, you may need to <a href="https://github.com/Valloric/YouCompleteMe/wiki/Building-Vim-from-source">compile Vim
from source</a> (don't worry, it's easy).</p>
<p>After you have made sure that you have Vim 7.4.143+, type the following in
Vim: <code>:echo has('python') || has('python3')</code>. The output should be 1. If
it's 0, then get a version of Vim with Python support.</p>
<p>On Windows, check also if your Vim architecture is 32 or 64-bit. This is
critical because it must match the Python and the YCM libraries
architectures. We recommend using a 64-bit Vim.</p>
</li>
<li>
<p><strong>Install YCM</strong> with <a href="https://github.com/VundleVim/Vundle.vim#about">Vundle</a> (or <a href="https://github.com/tpope/vim-pathogen#pathogenvim">Pathogen</a>, but Vundle is a better
    idea). With Vundle, this would mean adding a <code>Plugin
    'Valloric/YouCompleteMe'</code> line to your <a href="http://vimhelp.appspot.com/starting.txt.html#vimrc">vimrc</a>.</p>
<p>If you don't install YCM with Vundle, make sure you have run
<code>git submodule update --init --recursive</code> after checking out the YCM
repository (Vundle will do this for you) to fetch YCM's dependencies.</p>
</li>
<li>
<p>[Complete this step ONLY if you care about semantic completion support for
    C-family languages. Otherwise it's not necessary.]</p>
<p><strong>Download the latest version of <code>libclang</code></strong>. Clang is an open-source
compiler that can compile C/C++/Objective-C/Objective-C++. The <code>libclang</code>
library it provides is used to power the YCM semantic completion engine for
those languages. YCM is designed to work with libclang version 3.9 or
higher.</p>
<p>You can use the system libclang <em>only if you are sure it is version 3.9 or
higher</em>, otherwise don't. Even if it is, we recommend using the <a href="http://llvm.org/releases/download.html">official
binaries from llvm.org</a> if at all possible. Make sure you
download the correct archive file for your OS.</p>
<p>We <strong>STRONGLY recommend AGAINST use</strong> of the system libclang instead of
the upstream compiled binaries. Random things may break. Save yourself the
hassle and use the upstream pre-built libclang.</p>
</li>
<li>
<p><strong>Compile the <code>ycm_core</code> library</strong> that YCM needs. This library
    is the C++ engine that YCM uses to get fast completions.</p>
<p>You will need to have <code>cmake</code> installed in order to generate the required
makefiles. Linux users can install cmake with their package manager (<code>sudo
apt-get install cmake</code> for Ubuntu) whereas other users can <a href="https://cmake.org/download/">download and
install</a> cmake from its project site. Mac users can also get
it through <a href="http://brew.sh">Homebrew</a> with <code>brew install cmake</code>.</p>
<p>On a Unix OS, you need to make sure you have Python headers installed. On a
Debian-like Linux distro, this would be <code>sudo apt-get install python-dev
python3-dev</code>. On Mac they should already be present.</p>
<p>On Windows, you need to download and install <a href="https://www.python.org/downloads/windows/">Python 2 or
Python 3</a>. Pick the version corresponding to your Vim
architecture. You will also need Microsoft Visual C++ (MSVC) to build YCM.
You can obtain it by installing <a href="https://www.visualstudio.com/downloads/">Visual Studio</a>.
MSVC 12 (Visual Studio 2013), 14 (2015), and 15 (2017) are officially
supported.</p>
<p>Here we'll assume you installed YCM with Vundle. That means that the
top-level YCM directory is in <code>~/.vim/bundle/YouCompleteMe</code>.</p>
<p>We'll create a new folder where build files will be placed. Run the
following:</p>
<pre><code>cd ~
mkdir ycm_build
cd ycm_build
</code></pre>
<p>Now we need to generate the makefiles. If you DON'T care about semantic
support for C-family languages, run the following command in the <code>ycm_build</code>
directory:</p>
<pre><code>cmake -G "&lt;generator&gt;" . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp
</code></pre>
<p>where <code>&lt;generator&gt;</code> is <code>Unix Makefiles</code> on Unix systems and one of the
following Visual Studio generators on Windows:</p>
<ul>
<li><code>Visual Studio 11 Win64</code></li>
<li><code>Visual Studio 12 Win64</code></li>
<li><code>Visual Studio 14 Win64</code></li>
</ul>
<p>Remove the <code>Win64</code> part in these generators if your Vim architecture is
32-bit.</p>
<p>For those who want to use the system version of boost, you would pass
<code>-DUSE_SYSTEM_BOOST=ON</code> to cmake. This may be necessary on some systems
where the bundled version of boost doesn't compile out of the box.</p>
<p><strong>NOTE:</strong> We <strong>STRONGLY recommend AGAINST use</strong> of the system boost instead
of the bundled version of boost. Random things may break. Save yourself
the hassle and use the bundled version of boost.</p>
<p>If you DO care about semantic support for C-family languages, then your
<code>cmake</code> call will be a bit more complicated.  We'll assume you downloaded a
binary distribution of LLVM+Clang from llvm.org in step 3 and that you
extracted the archive file to folder <code>~/ycm_temp/llvm_root_dir</code> (with <code>bin</code>,
<code>lib</code>, <code>include</code> etc. folders right inside that folder). On Windows, you can
extract the files from the LLVM+Clang installer using <a href="http://www.7-zip.org/download.html">7-zip</a>.</p>
<p><strong>NOTE:</strong> This <em>only</em> works with a <em>downloaded</em> LLVM binary package, not a
custom-built LLVM! See docs below for <code>EXTERNAL_LIBCLANG_PATH</code> when using a
custom LLVM build.</p>
<p>With that in mind, run the following command in the <code>ycm_build</code> directory:</p>
<pre><code>cmake -G "&lt;generator&gt;" -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp
</code></pre>
<p>where <code>&lt;generator&gt;</code> is replaced like above.</p>
<p>Now that configuration files have been generated, compile the libraries
using this command:</p>
<pre><code>cmake --build . --target ycm_core --config Release
</code></pre>
<p>The <code>--config Release</code> part is specific to Windows and will be ignored on a
Unix OS.</p>
<p>For those who want to use the system version of libclang, you would pass
<code>-DUSE_SYSTEM_LIBCLANG=ON</code> to cmake <em>instead of</em> the
<code>-DPATH_TO_LLVM_ROOT=...</code> flag.</p>
<p><strong>NOTE:</strong> We <strong>STRONGLY recommend AGAINST use</strong> of the system libclang instead
of the upstream compiled binaries. Random things may break. Save yourself
the hassle and use the upstream pre-built libclang.</p>
<p>You could also force the use of a custom libclang library with
<code>-DEXTERNAL_LIBCLANG_PATH=/path/to/libclang.so</code> flag (the library would end
with <code>.dylib</code> on a Mac). Again, this flag would be used <em>instead of</em> the
other flags. <strong>If you compiled LLVM from source, this is the flag you should
be using.</strong></p>
<p>Running the <code>cmake</code> command will also place the <code>libclang.[so|dylib|dll]</code> in
the <code>YouCompleteMe/third_party/ycmd</code> folder for you if you compiled with
clang support (it needs to be there for YCM to work).</p>
</li>
<li>
<p>Set up support for additional languages, as desired:</p>
</li>
<li>
<p>C# support: install <a href="http://www.mono-project.com/docs/getting-started/install/">Mono on non-Windows platforms</a>. Navigate
    to <code>YouCompleteMe/third_party/ycmd/third_party/OmniSharpServer</code> and run
    <code>msbuild /property:Configuration=Release</code> on Windows. Replace <code>msbuild</code> by
    <code>xbuild</code> on other platforms. On Windows, be sure that <a href="http://stackoverflow.com/questions/6319274/how-do-i-run-msbuild-from-the-command-line-using-windows-sdk-7-1">the build utility
    <code>msbuild</code> is in your PATH</a>.</p>
</li>
<li>
<p>Go support: install <a href="https://golang.org/doc/install">Go</a> and add it to your path. Navigate to
    <code>YouCompleteMe/third_party/ycmd/third_party/gocode</code> and run <code>go build</code>.</p>
</li>
<li>
<p>TypeScript support: as with the quick installation, simply <code>npm install -g
    typescript</code> after successfully installing <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a>.</p>
</li>
<li>
<p>JavaScript support: install <a href="https://docs.npmjs.com/getting-started/installing-node">Node.js and npm</a>. Then navigate to
    <code>YouCompleteMe/third_party/ycmd/third_party/tern_runtime</code> and run <code>npm install
    --production</code></p>
</li>
<li>
<p>Rust support: install <a href="https://www.rust-lang.org/">Rust</a>. Navigate to
    <code>YouCompleteMe/third_party/ycmd/third_party/racerd</code> and run
    <code>cargo build --release</code>.</p>
</li>
</ol><p>That's it. You're done. Refer to the <em>User Guide</em> section on how to use YCM.
Don't forget that if you want the C-family semantic completion engine to work,
you will need to provide the compilation flags for your project to YCM. It's all
in the User Guide.</p><p>YCM comes with sane defaults for its options, but you still may want to take a
look at what's available for configuration. There are a few interesting options
that are conservatively turned off by default that you may want to turn on.</p><h2 id="quick-feature-summary">Quick Feature Summary</h2><h3 id="general-all-languages">General (all languages)</h3><ul>
<li>Super-fast identifier completer including tags files and syntax elements</li>
<li>Intelligent suggestion ranking and filtering</li>
<li>File and path suggestions</li>
<li>Suggestions from Vim's OmniFunc</li>
<li>UltiSnips snippet suggestions</li>
</ul><h3 id="c-family-languages-c-c-objective-c-objective-c">C-family languages (C, C++, Objective C, Objective C++)</h3><ul>
<li>Semantic auto-completion</li>
<li>Real-time diagnostic display</li>
<li>Go to include/declaration/definition (<code>GoTo</code>, etc.)</li>
<li>Semantic type information for identifiers (<code>GetType</code>)</li>
<li>Automatically fix certain errors (<code>FixIt</code>)</li>
<li>View documentation comments for identifiers (<code>GetDoc</code>)</li>
</ul><h3 id="c">Câ™¯</h3><ul>
<li>Semantic auto-completion</li>
<li>Real-time diagnostic display</li>
<li>Go to declaration/definition (<code>GoTo</code>, etc.)</li>
<li>Semantic type information for identifiers (<code>GetType</code>)</li>
<li>Automatically fix certain errors (<code>FixIt</code>)</li>
<li>Management of OmniSharp server instance</li>
<li>View documentation comments for identifiers (<code>GetDoc</code>)</li>
</ul><h3 id="python">Python</h3><ul>
<li>Intelligent auto-completion</li>
<li>Go to declaration/definition, find references (<code>GoTo</code>, <code>GoToReferences</code>)</li>
<li>View documentation comments for identifiers (<code>GetDoc</code>)</li>
<li>Restart <a href="https://github.com/vheon/JediHTTP">JediHTTP</a> server using a different Python interpreter</li>
</ul><h3 id="go">Go</h3><ul>
<li>Semantic auto-completion</li>
<li>Go to definition (<code>GoTo</code>)</li>
<li>Management of <code>gocode</code> server instance</li>
</ul><h3 id="typescript">TypeScript</h3><ul>
<li>Semantic auto-completion</li>
<li>Real-time diagnostic display</li>
<li>Renaming symbols (<code>RefactorRename &lt;new name&gt;</code>)</li>
<li>Go to definition, find references (<code>GoToDefinition</code>, <code>GoToReferences</code>)</li>
<li>Semantic type information for identifiers (<code>GetType</code>)</li>
<li>View documentation comments for identifiers (<code>GetDoc</code>)</li>
</ul><h3 id="javascript">JavaScript</h3><ul>
<li>Intelligent auto-completion</li>
<li>Renaming variables (<code>RefactorRename &lt;new name&gt;</code>)</li>
<li>Go to definition, find references (<code>GoToDefinition</code>, <code>GoToReferences</code>)</li>
<li>Type information for identifiers (<code>GetType</code>)</li>
<li>View documentation comments for identifiers (<code>GetDoc</code>)</li>
<li>Management of <code>Tern</code> server instance</li>
</ul><h3 id="rust">Rust</h3><ul>
<li>Semantic auto-completion</li>
<li>Go to definition (<code>GoTo</code>, <code>GoToDefinition</code>, and <code>GoToDeclaration</code> are
  identical)</li>
<li>Management of <code>racer</code> server instance</li>
<li>View documentation comments for identifiers (<code>GetDoc</code>)</li>
</ul><h2 id="user-guide">User Guide</h2><h3 id="general-usage">General Usage</h3><ul>
<li>If the offered completions are too broad, keep typing characters; YCM will
  continue refining the offered completions based on your input.</li>
<li>Filtering is "smart-case" sensitive; if you are typing only lowercase letters,
  then it's case-insensitive. If your input contains uppercase letters, then the
  uppercase letters in your query must match uppercase letters in the completion
  strings (the lowercase letters still match both). So, "foo" matches "Foo" and
  "foo", "Foo" matches "Foo" and "FOO" but not "foo".</li>
<li>Use the TAB key to accept a completion and continue pressing TAB to cycle
  through the completions. Use Shift-TAB to cycle backwards. Note that if you're
  using console Vim (that is, not Gvim or MacVim) then it's likely that the
  Shift-TAB binding will not work because the console will not pass it to Vim.
  You can remap the keys; see the <em><a href="https://github.com/Valloric/YouCompleteMe#options">Options</a></em> section below.</li>
</ul><p>Knowing a little bit about how YCM works internally will prevent confusion. YCM
has several completion engines: an identifier-based completer that collects all
of the identifiers in the current file and other files you visit (and your tags
files) and searches them when you type (identifiers are put into per-filetype
groups).</p><p>There are also several semantic engines in YCM. There's a libclang-based
completer that provides semantic completion for C-family languages.  There's a
Jedi-based completer for semantic completion for Python. There's also an
omnifunc-based completer that uses data from Vim's omnicomplete system to
provide semantic completions when no native completer exists for that language
in YCM.</p><p>There are also other completion engines, like the UltiSnips completer and the
filepath completer.</p><p>YCM automatically detects which completion engine would be the best in any
situation. On occasion, it queries several of them at once, merges the
outputs and presents the results to you.</p><h3 id="client-server-architecture">Client-Server Architecture</h3><p>YCM has a client-server architecture; the Vim part of YCM is only a thin client
that talks to the <a href="https://github.com/Valloric/ycmd">ycmd HTTP+JSON server</a> that has the vast majority of
YCM logic and functionality. The server is started and stopped automatically as
you start and stop Vim.</p><h3 id="completion-string-ranking">Completion String Ranking</h3><p>The subsequence filter removes any completions that do not match the input, but
then the sorting system kicks in. It's actually very complicated and uses lots
of factors, but suffice it to say that "word boundary" (WB) subsequence
character matches are "worth" more than non-WB matches. In effect, this means
given an input of "gua", the completion "getUserAccount" would be ranked higher
in the list than the "Fooguxa" completion (both of which are subsequence
matches). A word-boundary character are all capital characters, characters
preceded by an underscore and the first letter character in the completion
string.</p><h3 id="general-semantic-completion">General Semantic Completion</h3><ul>
<li>You can use Ctrl+Space to trigger the completion suggestions anywhere, even
  without a string prefix. This is useful to see which top-level functions are
  available for use.</li>
</ul><h3 id="c-family-semantic-completion">C-family Semantic Completion</h3><p>In order to perform semantic analysis such as code completion, <code>GoTo</code> and
diagnostics, YouCompleteMe uses <code>libclang</code>. This is the library version of the
clang compiler, sometimes also referred to as llvm. Like any compiler,
<code>libclang</code> requires a set of compile flags in order to parse your code. Simply
put: If <code>libclang</code> can't parse your code, YouCompleteMe can't provide semantic
analysis.</p><p>There are 2 methods which can be used to provide compile flags to <code>libclang</code>:</p><h4 id="option-1-use-a-compilation-database">Option 1: Use a <a href="http://clang.llvm.org/docs/JSONCompilationDatabase.html">compilation database</a></h4><p>The easiest way to get YCM to compile your code is to use a compilation
database.  A compilation database is usually generated by your build system
(e.g. <code>CMake</code>) and contains the compiler invocation for each compilation unit in
your project.</p><p>For information on how to generate a compilation database, see the <a href="http://clang.llvm.org/docs/JSONCompilationDatabase.html">clang
documentation</a>. In short:</p><ul>
<li>If using CMake, add <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code> when configuring (or
  add <code>set( CMAKE_EXPORT_COMPILE_COMMANDS ON )</code> to <code>CMakeLists.txt</code>) and copy or
  symlink the generated database to the root of your project.</li>
<li>If using Ninja, check out the <code>compdb</code> tool (<code>-t compdb</code>) in its
  <a href="https://ninja-build.org/manual.html">docs</a>.</li>
<li>If using GNU make, check out <a href="https://github.com/rizsotto/Bear">Bear</a>.</li>
<li>For other build systems, check out
  <a href="#option-2-provide-the-flags-manually"><code>.ycm_extra_conf.py</code></a> below.</li>
</ul><p>If no <a href="#option-2-provide-the-flags-manually"><code>.ycm_extra_conf.py</code></a> is found,
and no <a href="#the-gycm_global_ycm_extra_conf-option"><code>ycm_global_ycm_extra_conf</code></a> is
configured, YouCompleteMe automatically tries to load a compilation database if
one is found.</p><p>YCM looks for a file named <code>compile_commands.json</code> in the directory of the
opened file or in any directory above it in the hierarchy (recursively); when
the file is found, it is loaded.  YouCompleteMe performs the following lookups
when extracting flags for a particular file:</p><ul>
<li>If the database contains an entry for the file, the flags for that file are
  used.</li>
<li>If the file is a header file and a source file with the same root exists in
  the database, the flags for the source file are used. For example, if the file
  is <code>/home/Test/project/src/lib/something.h</code> and the database contains an entry
  for <code>/home/Test/project/src/lib/something.cc</code>, then the flags for
  <code>/home/Test/project/src/lib/something.cc</code> are used.</li>
<li>Otherwise, if any flags have been returned from the directory containing the
  requested file, those flags are used. This heuristic is intended to provide
  potentially working flags for newly created files.</li>
</ul><p>Finally, YCM converts any relative paths in the extracted flags to absolute
paths. This ensures that compilation can be performed from any Vim working
directory.</p><h4 id="option-2-provide-the-flags-manually">Option 2: Provide the flags manually</h4><p>If you don't have a compilation database, or aren't able to generate one,
you have to tell YouCompleteMe how to compile your code some other way.</p><p>Every c-family project is different. It is not possible for YCM to guess what
compiler flags to supply for your project. Fortunately, YCM provides a mechanism
for you to generate the flags for a particular file with <em>arbitrary complexity</em>.
This is achieved by requiring you to provide a Python module which implements a
trival function which, given the file name as argument, returns a list of
compiler flags to use to compile that file.</p><p>YCM looks for a <code>.ycm_extra_conf.py</code> file in the directory of the opened file or
in any directory above it in the hierarchy (recursively); when the file is
found, it is loaded (only once!) as a Python module. YCM calls a <code>FlagsForFile</code>
method in that module which should provide it with the information necessary to
compile the current file. You can also provide a path to a global
<code>.ycm_extra_conf.py</code> file, which will be used as a fallback. To prevent the
execution of malicious code from a file you didn't write YCM will ask you once
per <code>.ycm_extra_conf.py</code> if it is safe to load. This can be disabled and you can
white-/blacklist files. See the <em>Options</em> section for more details.</p><p>This system was designed this way so that the user can perform any arbitrary
sequence of operations to produce a list of compilation flags YCM should hand
to Clang.</p><p><strong>NOTE</strong>: It is highly recommended to include <code>-x &lt;language&gt;</code> flag to libclang.
This is so that the correct language is detected, particularly for header files.
Common values are <code>-x c</code> for C, <code>-x c++</code> for C++ and <code>-x objc</code> for Objective-C.</p><p>To give you an impression, if your c++ project is trivial, and your usual
compilation command is: <code>g++ -Wall -Wextra -Werror -o FILE.o FILE.cc</code>, then the
following <code>.ycm_extra_conf.py</code> is enough to get semantic analysis from
YouCompleteMe:</p><pre><code class="python">def FlagsForFile( filename, **kwargs ):
  return {
    'flags': [ '-x', 'c++', '-Wall', '-Wextra', '-Werror' ],
  }
</code></pre><p>As you can see from the trivial example, YCM calls the <code>FlagsForFile</code> method,
passing it the file name. The <code>**kwargs</code> is for advanced users and can usually
be ignored. The <code>FlagsForFile</code> function returns a dictionary with a single
element <code>'flags'</code>. This element is a <code>list</code> of compiler flags to pass to
libclang for the file <code>filename</code>. That's it! This is actually enough for most
projects, but for complex projects it is not uncommon to integrate directly with
an existing build system using the full power of the Python language.</p><p>For a more elaborate example,
<a href="https://github.com/Valloric/ycmd/blob/master/cpp/ycm/.ycm_extra_conf.py">see YCM's own <code>.ycm_extra_conf.py</code></a>. You should be able to use
it <em>as a starting point</em>. <strong>Don't</strong> just copy/paste that file somewhere and
expect things to magically work; <strong>your project needs different flags</strong>. Hint:
just replace the strings in the <code>flags</code> variable with compilation flags
necessary for your project. That should be enough for 99% of projects.</p><p>You could also consider using <a href="https://github.com/rdnetto/YCM-Generator">YCM-Generator</a> to generate the
<code>ycm_extra_conf.py</code> file.</p><h4 id="errors-during-compilaton">Errors during compilaton</h4><p>If Clang encounters errors when compiling the header files that your file
includes, then it's probably going to take a long time to get completions.  When
the completion menu finally appears, it's going to have a large number of
unrelated completion strings (type/function names that are not actually
members). This is because Clang fails to build a precompiled preamble for your
file if there are any errors in the included headers and that preamble is key to
getting fast completions.</p><p>Call the <code>:YcmDiags</code> command to see if any errors or warnings were detected in
your file.</p><h3 id="javascript-semantic-completion">JavaScript Semantic Completion</h3><h4 id="quick-start">Quick start</h4><ol>
<li>
<p>Ensure that you have enabled the Tern completer. See the
   <a href="#installation">installation guide</a> for details.</p>
</li>
<li>
<p>Create a <code>.tern-project</code> file in the root directory of your JavaScript
   project, by following the <a href="http://ternjs.net/doc/manual.html#configuration">instructions</a> in the <a href="http://ternjs.net">Tern</a>
   documentation.</p>
</li>
<li>
<p>Make sure that Vim's working directory is a descendent of that directory (or
   that directory itself) when working with JavaScript files.</p>
</li>
</ol><h4 id="explanation">Explanation</h4><p>JavaScript completion is based on <a href="http://ternjs.net">Tern</a>. This completion engine requires a
file named <a href="http://ternjs.net/doc/manual.html#configuration"><code>.tern-project</code></a> to exist in the current working
directory or a directory which is an ancestor of the current working directory
when the tern server is started. YCM starts the Tern server the first time a
JavaScript file is edited, so Vim's working directory at that time needs to be a
descendent of the directory containing the <code>.tern-project</code> file (or that
directory itself).</p><p>Alternatively, as described in the <a href="http://ternjs.net/doc/manual.html#server">Tern documentation</a>, a global
<code>.tern-config</code> file may be used.</p><p>Multiple Tern servers, are not supported. To switch to a different
JavaScript project, you can do one of the following:</p><ul>
<li>start a new instance of Vim from the new project's directory</li>
<li>change Vim's working directory (<code>:cd /path/to/new/project</code>) and restart the
  <a href="https://github.com/Valloric/ycmd">ycmd server</a> (<code>:YcmRestartServer</code>)</li>
<li>change Vim's working directory (<code>:cd /path/to/new/project</code>), open a JavaScript
  file (or set filetype to JavaScript) and restart the Tern server using YCM
  completer subcommand <code>:YcmCompleter RestartServer</code>.</li>
</ul><h4 id="tips-and-tricks">Tips and tricks</h4><p>This section contains some advice for configuring <code>.tern-project</code> and working
with JavaScript files. The canonical reference for correctly configuring Tern is
the <a href="http://ternjs.net/doc/manual.html#server">Tern documentation</a>. Any issues, improvements, advice, etc.
should be sought from the <a href="http://ternjs.net">Tern</a> project. For example, see the <a href="http://ternjs.net/doc/manual.html#plugins">list of tern
plugins</a> for the list of plugins
which can be enabled in the <code>plugins</code> section of the <code>.tern-project</code> file.</p><h5 id="configuring-tern-for-node-support">Configuring Tern for node support</h5><p>The following simple example <code>.tern-project</code> file enables nodejs support:</p><pre><code class="json">{
    "plugins": {
        "node": {}
    }
}

</code></pre><h5 id="configuring-tern-for-requirejs-support">Configuring Tern for requirejs support</h5><p>The Tern requirejs plugin requires that all included "libraries" are rooted
under the same base directory. If that's not the case for your projects, then it
is possible to make it work with appropriate symbolic links. For example, create
a directory <code>ext_lib</code> within your project and populate it with symlinks to your
libraries. Then set up the <code>.tern-project</code> something like this:</p><pre><code class="json">
{
  "plugins": {
    "requirejs": {
      "baseURL": "./ext_lib",
    }
  }
}
</code></pre><p>Then, given the following structure:</p><pre><code>./ext_lib/mylib (symlink)
./ext_lib/anotherlib (symlink)
</code></pre><p>Can be used as follows:</p><pre><code class="javascript">define( [ 'mylib/file1', 'anotherlib/anotherfile' ], function( f1, f2 ) {
    // etc.
} );
</code></pre><h3 id="rust-semantic-completion">Rust Semantic Completion</h3><p>Completions and GoTo commands within the current crate and its dependencies
should work out of the box with no additional configuration (provided that you
built YCM with the <code>--racer-completer</code> flag; see the <a href="#installation"><em>Installation</em>
section</a> for details).  For semantic analysis inclusive of the
standard library, you must have a local copy of <a href="https://www.rust-lang.org/downloads.html">the rust source
code</a>. You also need to set the following option so YouCompleteMe can
locate it.</p><pre><code class="viml">" In this example, the rust source code zip has been extracted to
" /usr/local/rust/rustc-1.5.0
let g:ycm_rust_src_path = '/usr/local/rust/rustc-1.5.0/src'
</code></pre><h3 id="python-semantic-completion">Python Semantic Completion</h3><p>Completion and GoTo commands work out of the box with no additional
configuration. Those features are provided by the <a href="https://github.com/davidhalter/jedi">jedi</a> library which
supports a variety of Python versions (2.6, 2.7, 3.2+) as long as it
runs in the corresponding Python interpreter. By default YCM runs <a href="https://github.com/davidhalter/jedi">jedi</a> with
the same Python interpreter used by the <a href="https://github.com/Valloric/ycmd">ycmd server</a>, so if you would like to
use a different interpreter, use the following option specifying the Python
binary to use. For example, to provide Python 3 completion in your project, set:</p><pre><code class="viml">let g:ycm_python_binary_path = '/usr/bin/python3'
</code></pre><p>If the value of <code>g:ycm_python_binary_path</code> is an absolute path like above it
will be used as-is, but if it's an executable name it will be searched through
the PATH. So for example if you set:</p><pre><code class="viml">let g:ycm_python_binary_path = 'python'
</code></pre><p>YCM will use the first <code>python</code> executable it finds in the PATH to run
<a href="https://github.com/davidhalter/jedi">jedi</a>. This means that if you are in a virtual environment and you start vim
in that directory, the first <code>python</code> that YCM will find will be the one in the
virtual environment, so <a href="https://github.com/davidhalter/jedi">jedi</a> will be able to provide completions for every
package you have in the virtual environment.</p><h3 id="semantic-completion-for-other-languages">Semantic Completion for Other Languages</h3><p>C-family, C#, Go, JavaScript, Python, Rust, and TypeScript languages are
supported natively by YouCompleteMe using the <a href="http://clang.llvm.org/">Clang</a>, <a href="https://github.com/OmniSharp/omnisharp-server">OmniSharp</a>,
<a href="https://github.com/nsf/gocode">Gocode</a>/<a href="https://github.com/Manishearth/godef">Godef</a>, <a href="http://ternjs.net">Tern</a>, <a href="https://github.com/davidhalter/jedi">Jedi</a>, <a href="https://github.com/phildawes/racer">racer</a>, and <a href="https://github.com/Microsoft/TypeScript/tree/master/src/server">TSServer</a> engines,
respectively. Check the <a href="#installation">installation</a> section for instructions
to enable these features if desired.</p><p>YCM will use your <code>omnifunc</code> (see <code>:h omnifunc</code> in Vim) as a source for semantic
completions if it does not have a native semantic completion engine for your
file's filetype. Vim comes with okayish omnifuncs for various languages like
Ruby, PHP, etc. It depends on the language.</p><p>You can get stellar omnifuncs for Java and Ruby with <a href="http://eclim.org/">Eclim</a>. Just make sure
you have the <em>latest</em> Eclim installed and configured (this means Eclim <code>&gt;= 2.2.*</code>
and Eclipse <code>&gt;= 4.2.*</code>).</p><p>After installing Eclim remember to create a new Eclipse project within your
application by typing <code>:ProjectCreate &lt;path-to-your-project&gt; -n ruby</code> (or <code>-n java</code>)
inside vim and don't forget to have <code>let g:EclimCompletionMethod = 'omnifunc'</code>
in your vimrc. This will make YCM and Eclim play nice; YCM will use Eclim's omnifuncs
as the data source for semantic completions and provide the auto-triggering
and subsequence-based matching (and other YCM features) on top of it.</p><h3 id="writing-new-semantic-completers">Writing New Semantic Completers</h3><p>You have two options here: writing an <code>omnifunc</code> for Vim's omnicomplete system
that YCM will then use through its omni-completer, or a custom completer for YCM
using the <a href="https://github.com/Valloric/ycmd/blob/master/ycmd/completers/completer.py">Completer API</a>.</p><p>Here are the differences between the two approaches:</p><ul>
<li>You have to use VimScript to write the omnifunc, but get to use Python to
  write for the Completer API; this by itself should make you want to use the
  API.</li>
<li>The Completer API is a <em>much</em> more powerful way to integrate with YCM and it
  provides a wider set of features. For instance, you can make your Completer
  query your semantic back-end in an asynchronous fashion, thus not blocking
  Vim's GUI thread while your completion system is processing stuff. This is
  impossible with VimScript. All of YCM's completers use the Completer API.</li>
<li>Performance with the Completer API is better since Python executes faster than
  VimScript.</li>
</ul><p>If you want to use the <code>omnifunc</code> system, see the relevant Vim docs with <code>:h
complete-functions</code>. For the Completer API, see <a href="https://github.com/Valloric/ycmd/blob/master/ycmd/completers/completer.py">the API docs</a>.</p><p>If you want to upstream your completer into YCM's source, you should use the
Completer API.</p><h3 id="diagnostic-display">Diagnostic Display</h3><p>YCM will display diagnostic notifications for C-family and C# languages if you
compiled YCM with Clang and Omnisharp support, respectively. Diagnostics will
also be displayed for TypeScript. Since YCM continuously recompiles your file as
you type, you'll get notified of errors and warnings in your file as fast as
possible.</p><p>Here are the various pieces of the diagnostic UI:</p><ul>
<li>Icons show up in the Vim gutter on lines that have a diagnostic.</li>
<li>Regions of text related to diagnostics are highlighted (by default, a red
  wavy underline in <code>gvim</code> and a red background in <code>vim</code>).</li>
<li>Moving the cursor to a line with a diagnostic echoes the diagnostic text.</li>
<li>Vim's location list is automatically populated with diagnostic data (off by
  default, see options).</li>
</ul><p>The new diagnostics (if any) will be displayed the next time you press any key
on the keyboard. So if you stop typing and just wait for the new diagnostics to
come in, that <em>will not work</em>. You need to press some key for the GUI to update.</p><p>Having to press a key to get the updates is unfortunate, but cannot be changed
due to the way Vim internals operate; there is no way that a background task can
update Vim's GUI after it has finished running.  You <em>have to</em> press a key. This
will make YCM check for any pending diagnostics updates.</p><p>You <em>can</em> force a full, blocking compilation cycle with the
<code>:YcmForceCompileAndDiagnostics</code> command (you may want to map that command to a
key; try putting <code>nnoremap &lt;F5&gt; :YcmForceCompileAndDiagnostics&lt;CR&gt;</code> in your
vimrc). Calling this command will force YCM to immediately recompile your file
and display any new diagnostics it encounters. Do note that recompilation with
this command may take a while and during this time the Vim GUI <em>will</em> be
blocked.</p><p>YCM will display a short diagnostic message when you move your cursor to the
line with the error. You can get a detailed diagnostic message with the
<code>&lt;leader&gt;d</code> key mapping (can be changed in the options) YCM provides when your
cursor is on the line with the diagnostic.</p><p>You can also see the full diagnostic message for all the diagnostics in the
current file in Vim's <code>locationlist</code>, which can be opened with the <code>:lopen</code> and
<code>:lclose</code> commands (make sure you have set <code>let
g:ycm_always_populate_location_list = 1</code> in your vimrc). A good way to toggle
the display of the <code>locationlist</code> with a single key mapping is provided by
another (very small) Vim plugin called <a href="https://github.com/Valloric/ListToggle">ListToggle</a> (which also makes it
possible to change the height of the <code>locationlist</code> window), also written by
yours truly.</p><h4 id="diagnostic-highlighting-groups">Diagnostic Highlighting Groups</h4><p>You can change the styling for the highlighting groups YCM uses. For the signs
in the Vim gutter, the relevant groups are:</p><ul>
<li><code>YcmErrorSign</code>, which falls back to group <code>SyntasticErrorSign</code> and then
  <code>error</code> if they exist</li>
<li><code>YcmWarningSign</code>, which falls back to group <code>SyntasticWarningSign</code> and then
  <code>todo</code> if they exist</li>
</ul><p>You can also style the line that has the warning/error with these groups:</p><ul>
<li><code>YcmErrorLine</code>, which falls back to group <code>SyntasticErrorLine</code> if it exists</li>
<li><code>YcmWarningLine</code>, which falls back to group <code>SyntasticWarningLine</code> if it
  exists</li>
</ul><p>Note that the line highlighting groups only work when gutter signs are turned
on.</p><p>The syntax groups used to highlight regions of text with errors/warnings:
- <code>YcmErrorSection</code>, which falls back to group <code>SyntasticError</code> if it exists and
  then <code>SpellBad</code>
- <code>YcmWarningSection</code>, which falls back to group <code>SyntasticWarning</code> if it exists
  and then <code>SpellCap</code></p><p>Here's how you'd change the style for a group:</p><pre><code class="viml">highlight YcmErrorLine guibg=#3f0000
</code></pre><h2 id="commands">Commands</h2><h3 id="the-ycmrestartserver-command">The <code>:YcmRestartServer</code> command</h3><p>If the <a href="https://github.com/Valloric/ycmd">ycmd completion server</a> suddenly stops for some reason, you can
restart it with this command.</p><h3 id="the-ycmforcecompileanddiagnostics-command">The <code>:YcmForceCompileAndDiagnostics</code> command</h3><p>Calling this command will force YCM to immediately recompile your file
and display any new diagnostics it encounters. Do note that recompilation with
this command may take a while and during this time the Vim GUI <em>will</em> be
blocked.</p><p>You may want to map this command to a key; try putting <code>nnoremap &lt;F5&gt;
:YcmForceCompileAndDiagnostics&lt;CR&gt;</code> in your vimrc.</p><h3 id="the-ycmdiags-command">The <code>:YcmDiags</code> command</h3><p>Calling this command will fill Vim's <code>locationlist</code> with errors or warnings if
any were detected in your file and then open it. If a given error or warning can
be fixed by a call to <code>:YcmCompleter FixIt</code>, then <code>(FixIt available)</code> is
appended to the error or warning text. See the <code>FixIt</code> completer subcommand for
more information.</p><p><strong>NOTE:</strong> The absense of <code>(FixIt available)</code> does not strictly imply a fix-it
is not available as not all completers are able to provide this indication. For
example, the c-sharp completer provides many fix-its but does not add this
additional indication.</p><p>The <code>g:ycm_open_loclist_on_ycm_diags</code> option can be used to prevent the location
list from opening, but still have it filled with new diagnostic data. See the
<em>Options</em> section for details.</p><h3 id="the-ycmshowdetaileddiagnostic-command">The <code>:YcmShowDetailedDiagnostic</code> command</h3><p>This command shows the full diagnostic text when the user's cursor is on the
line with the diagnostic.</p><h3 id="the-ycmdebuginfo-command">The <code>:YcmDebugInfo</code> command</h3><p>This will print out various debug information for the current file. Useful to
see what compile commands will be used for the file if you're using the semantic
completion engine.</p><h3 id="the-ycmtogglelogs-command">The <code>:YcmToggleLogs</code> command</h3><p>This command opens in separate windows the logfiles given as arguments or closes
them if they are already open in the editor. When no argument is given, list the
available logfiles. Only for debugging purpose.</p><h3 id="the-ycmcompleter-command">The <code>:YcmCompleter</code> command</h3><p>This command gives access to a number of additional <a href="#quick-feature-summary">IDE-like
features</a> in YCM, for things like semantic GoTo, type
information, FixIt and refactoring.</p><p>Technically the command invokes completer-specific commands.  If the first
argument is of the form <code>ft=...</code> the completer for that file type will be used
(for example <code>ft=cpp</code>), else the native completer of the current buffer will be
used.
Call <code>YcmCompleter</code> without further arguments for a list of the
commands you can call for the current completer.</p><p>See the <a href="#quick-feature-summary">file type feature summary</a> for an overview of
the features available for each file type. See the <em>YcmCompleter subcommands</em>
section for more information on the available subcommands and their usage.</p><h2 id="ycmcompleter-subcommands">YcmCompleter Subcommands</h2><p><strong>NOTE:</strong> See the docs for the <code>YcmCompleter</code> command before tackling this
section.</p><p>The invoked subcommand is automatically routed to the currently active semantic
completer, so <code>:YcmCompleter GoToDefinition</code> will invoke the <code>GoToDefinition</code>
subcommand on the Python semantic completer if the currently active file is a
Python one and on the Clang completer if the currently active file is a
C/C++/Objective-C one.</p><p>You may also want to map the subcommands to something less verbose; for
instance, <code>nnoremap &lt;leader&gt;jd :YcmCompleter GoTo&lt;CR&gt;</code>
maps the <code>&lt;leader&gt;jd</code> sequence to the longer subcommand invocation.</p><h3 id="goto-commands">GoTo Commands</h3><p>These commands are useful for jumping around and exploring code. When moving
the cursor, the subcommands add entries to Vim's <code>jumplist</code> so you can use
<code>CTRL-O</code> to jump back to where you where before invoking the command (and
<code>CTRL-I</code> to jump forward; see <code>:h jumplist</code> for details). If there is more
than one destination, the quickfix list (see <code>:h quickfix</code>) is populated with
the available locations and opened to full width at the bottom of the screen.
You can change this behavior by using <a href="#the-ycmquickfixopened-autocommand">the <code>YcmQuickFixOpened</code>
autocommand</a>.</p><h4 id="the-gotoinclude-subcommand">The <code>GoToInclude</code> subcommand</h4><p>Looks up the current line for a header and jumps to it.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp</code></p><h4 id="the-gotodeclaration-subcommand">The <code>GoToDeclaration</code> subcommand</h4><p>Looks up the symbol under the cursor and jumps to its declaration.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp, cs, go, python, rust</code></p><h4 id="the-gotodefinition-subcommand">The <code>GoToDefinition</code> subcommand</h4><p>Looks up the symbol under the cursor and jumps to its definition.</p><p><strong>NOTE:</strong> For C-family languages <strong>this only works in certain situations</strong>,
namely when the definition of the symbol is in the current translation unit. A
translation unit consists of the file you are editing and all the files you are
including with <code>#include</code> directives (directly or indirectly) in that file.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp, cs, go, javascript, python,
rust, typescript</code></p><h4 id="the-goto-subcommand">The <code>GoTo</code> subcommand</h4><p>This command tries to perform the "most sensible" GoTo operation it can.
Currently, this means that it tries to look up the symbol under the cursor and
jumps to its definition if possible; if the definition is not accessible from
the current translation unit, jumps to the symbol's declaration. For
C/C++/Objective-C, it first tries to look up the current line for a header and
jump to it. For C#, implementations are also considered and preferred.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp, cs, go, javascript, python, rust</code></p><h4 id="the-gotoimprecise-subcommand">The <code>GoToImprecise</code> subcommand</h4><p>WARNING: This command trades correctness for speed!</p><p>Same as the <code>GoTo</code> command except that it doesn't recompile the file with
libclang before looking up nodes in the AST. This can be very useful when you're
editing files that take long to compile but you know that you haven't made any
changes since the last parse that would lead to incorrect jumps. When you're
just browsing around your codebase, this command can spare you quite a bit of
latency.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp</code></p><h4 id="the-gotoreferences-subcommand">The <code>GoToReferences</code> subcommand</h4><p>This command attempts to find all of the references within the project to the
identifier under the cursor and populates the quickfix list with those
locations.</p><p>Supported in filetypes: <code>javascript, python, typescript</code></p><h4 id="the-gotoimplementation-subcommand">The <code>GoToImplementation</code> subcommand</h4><p>Looks up the symbol under the cursor and jumps to its implementation (i.e.
non-interface). If there are multiple implementations, instead provides a list
of implementations to choose from.</p><p>Supported in filetypes: <code>cs</code></p><h4 id="the-gotoimplementationelsedeclaration-subcommand">The <code>GoToImplementationElseDeclaration</code> subcommand</h4><p>Looks up the symbol under the cursor and jumps to its implementation if one,
else jump to its declaration. If there are multiple implementations, instead
provides a list of implementations to choose from.</p><p>Supported in filetypes: <code>cs</code></p><h3 id="semantic-information-commands">Semantic Information Commands</h3><p>These commands are useful for finding static information about the code, such
as the types of variables, viewing declarations and documentation strings.</p><h4 id="the-gettype-subcommand">The <code>GetType</code> subcommand</h4><p>Echos the type of the variable or method under the cursor, and where it differs,
the derived type.</p><p>For example:</p><pre><code class="c++">    std::string s;
</code></pre><p>Invoking this command on <code>s</code> returns <code>std::string =&gt; std::basic_string&lt;char&gt;</code></p><p><strong>NOTE:</strong> Due to limitations of <code>libclang</code>, invoking this command on the word
<code>auto</code> typically returns <code>auto</code>. However, invoking it on a usage of the variable
with inferred type returns the correct type, but typically it is repeated due to
<code>libclang</code> returning that the types differ.</p><p>For example:</p><pre><code class="c++">const char *s = "String";
auto x = &amp;s; // invoking on x or auto returns "auto";
             // invoking on s returns "const char *"
std::cout &lt;&lt; *x; // invoking on x returns "const char ** =&gt; const char **"
</code></pre><p><strong>NOTE:</strong> Causes re-parsing of the current translation unit.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp, javascript, typescript</code></p><h4 id="the-gettypeimprecise-subcommand">The <code>GetTypeImprecise</code> subcommand</h4><p>WARNING: This command trades correctness for speed!</p><p>Same as the <code>GetType</code> command except that it doesn't recompile the file with
libclang before looking up nodes in the AST. This can be very useful when you're
editing files that take long to compile but you know that you haven't made any
changes since the last parse that would lead to incorrect type. When you're
just browsing around your codebase, this command can spare you quite a bit of
latency.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp</code></p><h4 id="the-getparent-subcommand">The <code>GetParent</code> subcommand</h4><p>Echos the semantic parent of the point under the cursor.</p><p>The semantic parent is the item that semantically contains the given position.</p><p>For example:</p><pre><code class="c++">class C {
    void f();
};

void C::f() {

}
</code></pre><p>In the out-of-line definition of <code>C::f</code>, the semantic parent is the class <code>C</code>,
of which this function is a member.</p><p>In the example above, both declarations of <code>C::f</code> have <code>C</code> as their semantic
context, while the lexical context of the first <code>C::f</code> is <code>C</code> and the lexical
context of the second <code>C::f</code> is the translation unit.</p><p>For global declarations, the semantic parent is the translation unit.</p><p><strong>NOTE:</strong> Causes re-parsing of the current translation unit.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp</code></p><h4 id="the-getdoc-subcommand">The <code>GetDoc</code> subcommand</h4><p>Displays the preview window populated with quick info about the identifier
under the cursor. Depending on the file type, this includes things like:</p><ul>
<li>The type or declaration of identifier,</li>
<li>Doxygen/javadoc comments,</li>
<li>Python docstrings,</li>
<li>etc.</li>
</ul><p>Supported in filetypes: <code>c, cpp, objc, objcpp, cs, python, typescript,
javascript, rust</code></p><h4 id="the-getdocimprecise-subcommand">The <code>GetDocImprecise</code> subcommand</h4><p>WARNING: This command trades correctness for speed!</p><p>Same as the <code>GetDoc</code> command except that it doesn't recompile the file with
libclang before looking up nodes in the AST. This can be very useful when you're
editing files that take long to compile but you know that you haven't made any
changes since the last parse that would lead to incorrect docs. When you're
just browsing around your codebase, this command can spare you quite a bit of
latency.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp</code></p><h3 id="refactoring-and-fixit-commands">Refactoring and FixIt Commands</h3><p>These commands make changes to your source code in order to perform refactoring
or code correction. YouCompleteMe does not perform any action which cannot be
undone, and never saves or writes files to the disk.</p><h4 id="the-fixit-subcommand">The <code>FixIt</code> subcommand</h4><p>Where available, attempts to make changes to the buffer to correct diagnostics
on the current line. Where multiple suggestions are available (such as when
there are multiple ways to resolve a given warning, or where multiple
diagnostics are reported for the current line), the options are presented
and one can be selected.</p><p>Completers which provide diagnostics may also provide trivial modifications to
the source in order to correct the diagnostic. Examples include syntax errors
such as missing trailing semi-colons, spurious characters, or other errors which
the semantic engine can deterministically suggest corrections.</p><p>If no fix-it is available for the current line, or there is no diagnostic on the
current line, this command has no effect on the current buffer. If any
modifications are made, the number of changes made to the buffer is echo'd and
the user may use the editor's undo command to revert.</p><p>When a diagnostic is available, and <code>g:ycm_echo_current_diagnostic</code> is set to 1,
then the text <code>(FixIt)</code> is appended to the echo'd diagnostic when the
completer is able to add this indication. The text <code>(FixIt available)</code> is
also appended to the diagnostic text in the output of the <code>:YcmDiags</code> command
for any diagnostics with available fix-its (where the completer can provide this
indication).</p><p><strong>NOTE:</strong> Causes re-parsing of the current translation unit.</p><p><strong>NOTE:</strong> After applying a fix-it, the diagnostics UI is not immediately
updated.  This is due to a technical restriction in Vim. Moving the cursor, or
issuing the <code>:YcmForceCompileAndDiagnostics</code> command will refresh the
diagnostics.  Repeated invocations of the <code>FixIt</code> command on a given line,
however, <em>do</em> apply all diagnostics as expected without requiring refreshing of
the diagnostics UI.  This is particularly useful where there are multiple
diagnostics on one line, or where after fixing one diagnostic, another fix-it is
available.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp, cs</code></p><h4 id="the-refactorrename-new-name-subcommand">The <code>RefactorRename &lt;new name&gt;</code> subcommand</h4><p>In supported file types, this command attempts to perform a semantic rename of
the identifier under the cursor. This includes renaming declarations,
definitions and usages of the identifier, or any other language-appropriate
action. The specific behavior is defined by the semantic engine in use.</p><p>Similar to <code>FixIt</code>, this command applies automatic modifications to your source
files. Rename operations may involve changes to multiple files, which may or may
not be open in Vim buffers at the time. YouCompleteMe handles all of this for
you. The behavior is described in <a href="#multi-file-refactor">the following section</a>.</p><p>Supported in filetypes: <code>javascript</code> (variables only), <code>typescript</code></p><h4 id="multi-file-refactor">Multi-file Refactor</h4><p>When a Refactor or FixIt command touches multiple files, YouCompleteMe attempts
to apply those modifications to any existing open, visible buffer in the current
tab. If no such buffer can be found, YouCompleteMe opens the file in a new
small horizontal split at the top of the current window, applies the change,
and then <em>hides</em> the window. <strong>NOTE:</strong> The buffer remains open, and must be
manually saved. A confirmation dialog is opened prior to doing this to remind
you that this is about to happen.</p><p>Once the modifications have been made, the quickfix list (see <code>:help quickfix</code>)
is opened and populated with the locations of all modifications. This can be
used to review all automatic changes made. Typically, use the <code>CTRL-W
&lt;enter&gt;</code> combination to open the selected file in a new split. It is possible
to customize how the quickfix window is opened by using <a href="#the-ycmquickfixopened-autocommand">the <code>YcmQuickFixOpened</code>
autocommand</a>.</p><p>The buffers are <em>not</em> saved automatically. That is, you must save the modified
buffers manually after reviewing the changes from the quickfix list. Changes
can be undone using Vim's powerful undo features (see <code>:help undo</code>). Note
that Vim's undo is per-buffer, so to undo all changes, the undo commands must
be applied in each modified buffer separately.</p><p><strong>NOTE:</strong> While applying modifications, Vim may find files which are already
open and have a swap file. The command is aborted if you select Abort or Quit in
any such prompts. This leaves the Refactor operation partially complete and must
be manually corrected using Vim's undo features. The quickfix list is <em>not</em>
populated in this case. Inspect <code>:buffers</code> or equivalent (see <code>:help buffers</code>)
to see the buffers that were opened by the command.</p><h3 id="miscellaneous-commands">Miscellaneous Commands</h3><p>These commands are for general administration, rather than IDE-like features.
They cover things like the semantic engine server instance and compilation
flags.</p><h4 id="the-restartserver-subcommand">The <code>RestartServer</code> subcommand</h4><p>Restarts the semantic-engine-as-localhost-server for those semantic engines that
work as separate servers that YCM talks to.</p><p>An additional optional argument may be supplied for Python, specifying the
python binary to use to restart the Python semantic engine.</p><pre><code class="viml">:YcmCompleter RestartServer /usr/bin/python3.4
</code></pre><p>Supported in filetypes: <code>cs, go, javascript, python, rust, typescript</code></p><h4 id="the-clearcompilationflagcache-subcommand">The <code>ClearCompilationFlagCache</code> subcommand</h4><p>YCM caches the flags it gets from the <code>FlagsForFile</code> function in your
<code>ycm_extra_conf.py</code> file if you return them with the <code>do_cache</code> parameter set to
<code>True</code>. The cache is in memory and is never invalidated (unless you restart Vim
of course).</p><p>This command clears that cache entirely. YCM will then re-query your
<code>FlagsForFile</code> function as needed in the future.</p><p>Supported in filetypes: <code>c, cpp, objc, objcpp</code></p><h4 id="the-reloadsolution-subcommand">The <code>ReloadSolution</code> subcommand</h4><p>Instruct the Omnisharp server to clear its cache and reload all files from disk.
This is useful when files are added, removed, or renamed in the solution, files
are changed outside of Vim, or whenever Omnisharp cache is out-of-sync.</p><p>Supported in filetypes: <code>cs</code></p><h2 id="functions">Functions</h2><h3 id="the-youcompletemegeterrorcount-function">The <code>youcompleteme#GetErrorCount</code> function</h3><p>Get the number of YCM Diagnostic errors. If no errors are present, this function
returns 0.</p><p>For example:</p><pre><code class="viml">  call youcompleteme#GetErrorCount()
</code></pre><p>Both this function and <code>youcompleteme#GetWarningCount</code> can be useful when
integrating YCM with other Vim plugins. For example, a <a href="https://github.com/itchyny/lightline.vim">lightline</a> user could
add a diagnostics section to their statusline which would display the number of
errors and warnings.</p><h3 id="the-youcompletemegetwarningcount-function">The <code>youcompleteme#GetWarningCount</code> function</h3><p>Get the number of YCM Diagnostic warnings. If no warnings are present, this
function returns 0.</p><p>For example:</p><pre><code class="viml">  call youcompleteme#GetWarningCount()
</code></pre><h2 id="autocommands">Autocommands</h2><h3 id="the-ycmlocationopened-autocommand">The <code>YcmLocationOpened</code> autocommand</h3><p>This <code>User</code> autocommand is fired when YCM opens the location list window in
response to the <code>YcmDiags</code> command. By default, the location list window is
opened to full width at the bottom of the screen and its height is set to fit
all entries. This behavior can be overridden by using the <code>YcmLocationOpened</code>
autocommand which is triggered while the cursor is in the location list window.
For instance:</p><pre><code class="viml">function! s:CustomizeYcmLocationWindow()
  " Move the window to the top of the screen.
  execute "wincmd K"
  " Set the window height to 5.
  execute "5wincmd _"
endfunction

autocmd User YcmLocationOpened call s:CustomizeYcmLocationWindow()
</code></pre><h3 id="the-ycmquickfixopened-autocommand">The <code>YcmQuickFixOpened</code> autocommand</h3><p>This <code>User</code> autocommand is fired when YCM opens the quickfix window in response
to the <code>GoTo*</code> and <code>RefactorRename</code> subcommands. By default, the quickfix window
is opened to full width at the bottom of the screen and its height is set to fit
all entries. This behavior can be overridden by using the <code>YcmQuickFixOpened</code>
autocommand which is triggered while the cursor is in the quickfix window. For
instance:</p><pre><code class="viml">function! s:CustomizeYcmQuickFixWindow()
  " Move the window to the top of the screen.
  execute "wincmd K"
  " Set the window height to 5.
  execute "5wincmd _"
endfunction

autocmd User YcmQuickFixOpened call s:CustomizeYcmQuickFixWindow()
</code></pre><h2 id="options">Options</h2><p>All options have reasonable defaults so if the plug-in works after installation
you don't need to change any options. These options can be configured in your
<a href="http://vimhelp.appspot.com/starting.txt.html#vimrc">vimrc script</a> by including a line like this:</p><pre><code class="viml">let g:ycm_min_num_of_chars_for_completion = 1
</code></pre><p>Note that after changing an option in your <a href="http://vimhelp.appspot.com/starting.txt.html#vimrc">vimrc script</a> you have to
restart Vim for the changes to take effect.</p><h3 id="the-gycm_min_num_of_chars_for_completion-option">The <code>g:ycm_min_num_of_chars_for_completion</code> option</h3><p>This option controls the number of characters the user needs to type before
identifier-based completion suggestions are triggered. For example, if the
option is set to <code>2</code>, then when the user types a second alphanumeric character
after a whitespace character, completion suggestions will be triggered. This
option is NOT used for semantic completion.</p><p>Setting this option to a high number like <code>99</code> effectively turns off the
identifier completion engine and just leaves the semantic engine.</p><p>Default: <code>2</code></p><pre><code class="viml">let g:ycm_min_num_of_chars_for_completion = 2
</code></pre><h3 id="the-gycm_min_num_identifier_candidate_chars-option">The <code>g:ycm_min_num_identifier_candidate_chars</code> option</h3><p>This option controls the minimum number of characters that a completion
candidate coming from the identifier completer must have to be shown in the
popup menu.</p><p>A special value of <code>0</code> means there is no limit.</p><p><strong>NOTE:</strong> This option only applies to the identifier completer; it has no effect
on the various semantic completers.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_min_num_identifier_candidate_chars = 0
</code></pre><h3 id="the-gycm_auto_trigger-option">The <code>g:ycm_auto_trigger</code> option</h3><p>When set to <code>0</code>, this option turns off YCM's identifier completer (the
as-you-type popup) <em>and</em> the semantic triggers (the popup you'd get after typing
<code>.</code> or <code>-&gt;</code> in say C++). You can still force semantic completion with the
<code>&lt;C-Space&gt;</code> shortcut.</p><p>If you want to just turn off the identifier completer but keep the semantic
triggers, you should set <code>g:ycm_min_num_of_chars_for_completion</code> to a high
number like <code>99</code>.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_auto_trigger = 1
</code></pre><h3 id="the-gycm_filetype_whitelist-option">The <code>g:ycm_filetype_whitelist</code> option</h3><p>This option controls for which Vim filetypes (see <code>:h filetype</code>) should YCM be
turned on. The option value should be a Vim dictionary with keys being filetype
strings (like <code>python</code>, <code>cpp</code> etc) and values being unimportant (the dictionary
is used like a hash set, meaning that only the keys matter).</p><p>The <code>*</code> key is special and matches all filetypes. By default, the whitelist
contains only this <code>*</code> key.</p><p>YCM also has a <code>g:ycm_filetype_blacklist</code> option that lists filetypes for which
YCM shouldn't be turned on. YCM will work only in filetypes that both the
whitelist and the blacklist allow (the blacklist "allows" a filetype by <em>not</em>
having it as a key).</p><p>For example, let's assume you want YCM to work in files with the <code>cpp</code> filetype.
The filetype should then be present in the whitelist either directly (<code>cpp</code> key
in the whitelist) or indirectly through the special <code>*</code> key. It should <em>not</em> be
present in the blacklist.</p><p>Filetypes that are blocked by the either of the lists will be completely ignored
by YCM, meaning that neither the identifier-based completion engine nor the
semantic engine will operate in them.</p><p>You can get the filetype of the current file in Vim with <code>:set ft?</code>.</p><p>Default: <code>{'*' : 1}</code></p><pre><code class="viml">let g:ycm_filetype_whitelist = { '*': 1 }
</code></pre><h3 id="the-gycm_filetype_blacklist-option">The <code>g:ycm_filetype_blacklist</code> option</h3><p>This option controls for which Vim filetypes (see <code>:h filetype</code>) should YCM be
turned off. The option value should be a Vim dictionary with keys being filetype
strings (like <code>python</code>, <code>cpp</code> etc) and values being unimportant (the dictionary
is used like a hash set, meaning that only the keys matter).</p><p>See the <code>g:ycm_filetype_whitelist</code> option for more details on how this works.</p><p>Default: <code>[see next line]</code></p><pre><code class="viml">let g:ycm_filetype_blacklist = {
      \ 'tagbar' : 1,
      \ 'qf' : 1,
      \ 'notes' : 1,
      \ 'markdown' : 1,
      \ 'unite' : 1,
      \ 'text' : 1,
      \ 'vimwiki' : 1,
      \ 'pandoc' : 1,
      \ 'infolog' : 1,
      \ 'mail' : 1
      \}
</code></pre><h3 id="the-gycm_filetype_specific_completion_to_disable-option">The <code>g:ycm_filetype_specific_completion_to_disable</code> option</h3><p>This option controls for which Vim filetypes (see <code>:h filetype</code>) should the YCM
semantic completion engine be turned off. The option value should be a Vim
dictionary with keys being filetype strings (like <code>python</code>, <code>cpp</code> etc) and
values being unimportant (the dictionary is used like a hash set, meaning that
only the keys matter). The listed filetypes will be ignored by the YCM semantic
completion engine, but the identifier-based completion engine will still trigger
in files of those filetypes.</p><p>Note that even if semantic completion is not turned off for a specific filetype,
you will not get semantic completion if the semantic engine does not support
that filetype.</p><p>You can get the filetype of the current file in Vim with <code>:set ft?</code>.</p><p>Default: <code>[see next line]</code></p><pre><code class="viml">let g:ycm_filetype_specific_completion_to_disable = {
      \ 'gitcommit': 1
      \}
</code></pre><h3 id="the-gycm_show_diagnostics_ui-option">The <code>g:ycm_show_diagnostics_ui</code> option</h3><p>When set, this option turns on YCM's diagnostic display features. See the
<em>Diagnostic display</em> section in the <em>User Manual</em> for more details.</p><p>Specific parts of the diagnostics UI (like the gutter signs, text highlighting,
diagnostic echo and auto location list population) can be individually turned on
or off. See the other options below for details.</p><p>Note that YCM's diagnostics UI is only supported for C-family languages.</p><p>When set, this option also makes YCM remove all Syntastic checkers set for the
<code>c</code>, <code>cpp</code>, <code>objc</code> and <code>objcpp</code> filetypes since this would conflict with YCM's
own diagnostics UI.</p><p>If you're using YCM's identifier completer in C-family languages but cannot use
the clang-based semantic completer for those languages <em>and</em> want to use the GCC
Syntastic checkers, unset this option.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_show_diagnostics_ui = 1
</code></pre><h3 id="the-gycm_error_symbol-option">The <code>g:ycm_error_symbol</code> option</h3><p>YCM will use the value of this option as the symbol for errors in the Vim
gutter.</p><p>This option is part of the Syntastic compatibility layer; if the option is not
set, YCM will fall back to the value of the <code>g:syntastic_error_symbol</code> option
before using this option's default.</p><p>Default: <code>&gt;&gt;</code></p><pre><code class="viml">let g:ycm_error_symbol = '&gt;&gt;'
</code></pre><h3 id="the-gycm_warning_symbol-option">The <code>g:ycm_warning_symbol</code> option</h3><p>YCM will use the value of this option as the symbol for warnings in the Vim
gutter.</p><p>This option is part of the Syntastic compatibility layer; if the option is not
set, YCM will fall back to the value of the <code>g:syntastic_warning_symbol</code> option
before using this option's default.</p><p>Default: <code>&gt;&gt;</code></p><pre><code class="viml">let g:ycm_warning_symbol = '&gt;&gt;'
</code></pre><h3 id="the-gycm_enable_diagnostic_signs-option">The <code>g:ycm_enable_diagnostic_signs</code> option</h3><p>When this option is set, YCM will put icons in Vim's gutter on lines that have a
diagnostic set. Turning this off will also turn off the <code>YcmErrorLine</code> and
<code>YcmWarningLine</code> highlighting.</p><p>This option is part of the Syntastic compatibility layer; if the option is not
set, YCM will fall back to the value of the <code>g:syntastic_enable_signs</code> option
before using this option's default.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_enable_diagnostic_signs = 1
</code></pre><h3 id="the-gycm_enable_diagnostic_highlighting-option">The <code>g:ycm_enable_diagnostic_highlighting</code> option</h3><p>When this option is set, YCM will highlight regions of text that are related to
the diagnostic that is present on a line, if any.</p><p>This option is part of the Syntastic compatibility layer; if the option is not
set, YCM will fall back to the value of the <code>g:syntastic_enable_highlighting</code>
option before using this option's default.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_enable_diagnostic_highlighting = 1
</code></pre><h3 id="the-gycm_echo_current_diagnostic-option">The <code>g:ycm_echo_current_diagnostic</code> option</h3><p>When this option is set, YCM will echo the text of the diagnostic present on the
current line when you move your cursor to that line. If a <code>FixIt</code> is available
for the current diagnostic, then <code>(FixIt)</code> is appended.</p><p>This option is part of the Syntastic compatibility layer; if the option is not
set, YCM will fall back to the value of the <code>g:syntastic_echo_current_error</code>
option before using this option's default.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_echo_current_diagnostic = 1
</code></pre><h3 id="the-gycm_filter_diagnostics-option">The <code>g:ycm_filter_diagnostics</code> option</h3><p>This option controls which diagnostics will be rendered by YCM. This option
holds a dictionary of key-values, where the keys are Vim's filetype strings
delimited by commas and values are dictionaries describing the filter.</p><p>A filter is a dictionary of key-values, where the keys are the type of filter,
and the value is a list of arguments to that filter. In the case of just a
single item in the list, you may omit the brackets and just provide the argument
directly. If any filter matches a diagnostic, it will be dropped and YCM will 
not render it.</p><p>The following filter types are supported:</p><ul>
<li>"regex": Accepts a string <a href="https://docs.python.org/2/library/re.html#regular-expression-syntax">regular expression</a>. This type matches
when the regex (treated as case-insensitive) is found in the diagnostic text.</li>
<li>"level": Accepts a string level, either "warning" or "error." This type 
matches when the diagnostic has the same level.</li>
</ul><p><strong>NOTE:</strong> The regex syntax is <strong>NOT</strong> Vim's, it's <a href="https://docs.python.org/2/library/re.html#regular-expression-syntax">Python's</a>.</p><p>Default: <code>{}</code></p><pre><code class="viml">let g:ycm_filter_diagnostics = {
  \ "java": {
  \      "regex": [ ".*taco.*", ... ],
  \      "level": "error",
  \      ...
  \    }
  \ }
</code></pre><h3 id="the-gycm_always_populate_location_list-option">The <code>g:ycm_always_populate_location_list</code> option</h3><p>When this option is set, YCM will populate the location list automatically every
time it gets new diagnostic data. This option is off by default so as not to
interfere with other data you might have placed in the location list.</p><p>See <code>:help location-list</code> in Vim to learn more about the location list.</p><p>This option is part of the Syntastic compatibility layer; if the option is not
set, YCM will fall back to the value of the
<code>g:syntastic_always_populate_loc_list</code> option before using this option's
default.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_always_populate_location_list = 0
</code></pre><h3 id="the-gycm_open_loclist_on_ycm_diags-option">The <code>g:ycm_open_loclist_on_ycm_diags</code> option</h3><p>When this option is set, <code>:YcmDiags</code> will automatically open the location list
after forcing a compilation and filling the list with diagnostic data.</p><p>See <code>:help location-list</code> in Vim to learn more about the location list.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_open_loclist_on_ycm_diags = 1
</code></pre><h3 id="the-gycm_allow_changing_updatetime-option">The <code>g:ycm_allow_changing_updatetime</code> option</h3><p>When this option is set to <code>1</code>, YCM will change the <code>updatetime</code> Vim option to
<code>2000</code> (see <code>:h updatetime</code>). This may conflict with some other plugins you have
(but it's unlikely). The <code>updatetime</code> option is the number of milliseconds that
have to pass before Vim's <code>CursorHold</code> (see <code>:h CursorHold</code>) event fires. YCM
runs the completion engines' "file comprehension" systems in the background on
every such event; the identifier-based engine collects the identifiers whereas
the semantic engine compiles the file to build an AST.</p><p>The Vim default of <code>4000</code> for <code>updatetime</code> is a bit long, so YCM reduces
this. Set this option to <code>0</code> to force YCM to leave your <code>updatetime</code> setting
alone.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_allow_changing_updatetime = 1
</code></pre><h3 id="the-gycm_complete_in_comments-option">The <code>g:ycm_complete_in_comments</code> option</h3><p>When this option is set to <code>1</code>, YCM will show the completion menu even when
typing inside comments.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_complete_in_comments = 0
</code></pre><h3 id="the-gycm_complete_in_strings-option">The <code>g:ycm_complete_in_strings</code> option</h3><p>When this option is set to <code>1</code>, YCM will show the completion menu even when
typing inside strings.</p><p>Note that this is turned on by default so that you can use the filename
completion inside strings. This is very useful for instance in C-family files
where typing <code>#include "</code> will trigger the start of filename completion. If you
turn off this option, you will turn off filename completion in such situations
as well.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_complete_in_strings = 1
</code></pre><h3 id="the-gycm_collect_identifiers_from_comments_and_strings-option">The <code>g:ycm_collect_identifiers_from_comments_and_strings</code> option</h3><p>When this option is set to <code>1</code>, YCM's identifier completer will also collect
identifiers from strings and comments. Otherwise, the text in comments and
strings will be ignored.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_collect_identifiers_from_comments_and_strings = 0
</code></pre><h3 id="the-gycm_collect_identifiers_from_tags_files-option">The <code>g:ycm_collect_identifiers_from_tags_files</code> option</h3><p>When this option is set to <code>1</code>, YCM's identifier completer will also collect
identifiers from tags files. The list of tags files to examine is retrieved from
the <code>tagfiles()</code> Vim function which examines the <code>tags</code> Vim option. See <code>:h
'tags'</code> for details.</p><p>YCM will re-index your tags files if it detects that they have been modified.</p><p>The only supported tag format is the <a href="http://ctags.sourceforge.net/FORMAT">Exuberant Ctags format</a>. The
format from "plain" ctags is NOT supported. Ctags needs to be called with the
<code>--fields=+l</code> option (that's a lowercase <code>L</code>, not a one) because YCM needs the
<code>language:&lt;lang&gt;</code> field in the tags output.</p><p>See the <em>FAQ</em> for pointers if YCM does not appear to read your tag files.</p><p>This option is off by default because it makes Vim slower if your tags are on a
network directory.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_collect_identifiers_from_tags_files = 0
</code></pre><h3 id="the-gycm_seed_identifiers_with_syntax-option">The <code>g:ycm_seed_identifiers_with_syntax</code> option</h3><p>When this option is set to <code>1</code>, YCM's identifier completer will seed its
identifier database with the keywords of the programming language you're
writing.</p><p>Since the keywords are extracted from the Vim syntax file for the filetype, all
keywords may not be collected, depending on how the syntax file was written.
Usually at least 95% of the keywords are successfully extracted.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_seed_identifiers_with_syntax = 0
</code></pre><h3 id="the-gycm_extra_conf_vim_data-option">The <code>g:ycm_extra_conf_vim_data</code> option</h3><p>If you're using semantic completion for C-family files, this option might come
handy; it's a way of sending data from Vim to your <code>FlagsForFile</code> function in
your <code>.ycm_extra_conf.py</code> file.</p><p>This option is supposed to be a list of VimScript expression strings that are
evaluated for every request to the <a href="https://github.com/Valloric/ycmd">ycmd server</a> and then passed to your
<code>FlagsForFile</code> function as a <code>client_data</code> keyword argument.</p><p>For instance, if you set this option to <code>['v:version']</code>, your <code>FlagsForFile</code>
function will be called like this:</p><pre><code class="python"># The '704' value is of course contingent on Vim 7.4; in 7.3 it would be '703'
FlagsForFile(filename, client_data = {'v:version': 704})
</code></pre><p>So the <code>client_data</code> parameter is a dictionary mapping Vim expression strings to
their values at the time of the request.</p><p>The correct way to define parameters for your <code>FlagsForFile</code> function:</p><pre><code class="python">def FlagsForFile(filename, **kwargs):
</code></pre><p>You can then get to <code>client_data</code> with <code>kwargs['client_data']</code>.</p><p>Default: <code>[]</code></p><pre><code class="viml">let g:ycm_extra_conf_vim_data = []
</code></pre><h3 id="the-gycm_server_python_interpreter-option">The <code>g:ycm_server_python_interpreter</code> option</h3><p>YCM will by default search for an appropriate Python interpreter on your system.
You can use this option to override that behavior and force the use of a
specific interpreter of your choosing.</p><p><strong>NOTE:</strong> This interpreter is only used for the <a href="https://github.com/Valloric/ycmd">ycmd server</a>. The YCM
client running inside Vim always uses the Python interpreter that's embedded
inside Vim.</p><p>Default: <code>''</code></p><pre><code class="viml">let g:ycm_server_python_interpreter = ''
</code></pre><h3 id="the-gycm_keep_logfiles-option">The <code>g:ycm_keep_logfiles</code> option</h3><p>When this option is set to <code>1</code>, YCM and the <a href="https://github.com/Valloric/ycmd">ycmd completion server</a> will
keep the logfiles around after shutting down (they are deleted on shutdown by
default).</p><p>To see where the logfiles are, call <code>:YcmDebugInfo</code>.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_keep_logfiles = 0
</code></pre><h3 id="the-gycm_log_level-option">The <code>g:ycm_log_level</code> option</h3><p>The logging level that YCM and the <a href="https://github.com/Valloric/ycmd">ycmd completion server</a> use. Valid
values are the following, from most verbose to least verbose:
- <code>debug</code>
- <code>info</code>
- <code>warning</code>
- <code>error</code>
- <code>critical</code></p><p>Note that <code>debug</code> is <em>very</em> verbose.</p><p>Default: <code>info</code></p><pre><code class="viml">let g:ycm_log_level = 'info'
</code></pre><h3 id="the-gycm_auto_start_csharp_server-option">The <code>g:ycm_auto_start_csharp_server</code> option</h3><p>When set to <code>1</code>, the OmniSharp server will be automatically started (once per
Vim session) when you open a C# file.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_auto_start_csharp_server = 1
</code></pre><h3 id="the-gycm_auto_stop_csharp_server-option">The <code>g:ycm_auto_stop_csharp_server</code> option</h3><p>When set to <code>1</code>, the OmniSharp server will be automatically stopped upon
closing Vim.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_auto_stop_csharp_server = 1
</code></pre><h3 id="the-gycm_csharp_server_port-option">The <code>g:ycm_csharp_server_port</code> option</h3><p>When g:ycm_auto_start_csharp_server is set to <code>1</code>, specifies the port for
the OmniSharp server to listen on. When set to <code>0</code> uses an unused port provided
by the OS.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_csharp_server_port = 0
</code></pre><h3 id="the-gycm_csharp_insert_namespace_expr-option">The <code>g:ycm_csharp_insert_namespace_expr</code> option</h3><p>By default, when YCM inserts a namespace, it will insert the <code>using</code> statement
under the nearest <code>using</code> statement. You may prefer that the <code>using</code> statement is
inserted somewhere, for example, to preserve sorting. If so, you can set this
option to override this behavior.</p><p>When this option is set, instead of inserting the <code>using</code> statement itself, YCM
will set the global variable <code>g:ycm_namespace_to_insert</code> to the namespace to
insert, and then evaluate this option's value as an expression. The option's
expression is responsible for inserting the namespace - the default insertion
will not occur.</p><p>Default: ''</p><pre><code class="viml">let g:ycm_csharp_insert_namespace_expr = ''
</code></pre><h3 id="the-gycm_add_preview_to_completeopt-option">The <code>g:ycm_add_preview_to_completeopt</code> option</h3><p>When this option is set to <code>1</code>, YCM will add the <code>preview</code> string to Vim's
<code>completeopt</code> option (see <code>:h completeopt</code>). If your <code>completeopt</code> option
already has <code>preview</code> set, there will be no effect. You can see the current
state of your <code>completeopt</code> setting with <code>:set completeopt?</code> (yes, the question
mark is important).</p><p>When <code>preview</code> is present in <code>completeopt</code>, YCM will use the <code>preview</code> window at
the top of the file to store detailed information about the current completion
candidate (but only if the candidate came from the semantic engine). For
instance, it would show the full function prototype and all the function
overloads in the window if the current completion is a function name.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_add_preview_to_completeopt = 0
</code></pre><h3 id="the-gycm_autoclose_preview_window_after_completion-option">The <code>g:ycm_autoclose_preview_window_after_completion</code> option</h3><p>When this option is set to <code>1</code>, YCM will auto-close the <code>preview</code> window after
the user accepts the offered completion string. If there is no <code>preview</code> window
triggered because there is no <code>preview</code> string in <code>completeopt</code>, this option is
irrelevant. See the <code>g:ycm_add_preview_to_completeopt</code> option for more details.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_autoclose_preview_window_after_completion = 0
</code></pre><h3 id="the-gycm_autoclose_preview_window_after_insertion-option">The <code>g:ycm_autoclose_preview_window_after_insertion</code> option</h3><p>When this option is set to <code>1</code>, YCM will auto-close the <code>preview</code> window after
the user leaves insert mode. This option is irrelevant if
<code>g:ycm_autoclose_preview_window_after_completion</code> is set or if no <code>preview</code>
window is triggered. See the <code>g:ycm_add_preview_to_completeopt</code> option for more
details.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_autoclose_preview_window_after_insertion = 0
</code></pre><h3 id="the-gycm_max_diagnostics_to_display-option">The <code>g:ycm_max_diagnostics_to_display</code> option</h3><p>This option controls the maximum number of diagnostics shown to the user when
errors or warnings are detected in the file. This option is only relevant if you
are using the C-family semantic completion engine.</p><p>Default: <code>30</code></p><pre><code class="viml">let g:ycm_max_diagnostics_to_display = 30
</code></pre><h3 id="the-gycm_key_list_select_completion-option">The <code>g:ycm_key_list_select_completion</code> option</h3><p>This option controls the key mappings used to select the first completion
string.  Invoking any of them repeatedly cycles forward through the completion
list.</p><p>Some users like adding <code>&lt;Enter&gt;</code> to this list.</p><p>Default: <code>['&lt;TAB&gt;', '&lt;Down&gt;']</code></p><pre><code class="viml">let g:ycm_key_list_select_completion = ['&lt;TAB&gt;', '&lt;Down&gt;']
</code></pre><h3 id="the-gycm_key_list_previous_completion-option">The <code>g:ycm_key_list_previous_completion</code> option</h3><p>This option controls the key mappings used to select the previous completion
string. Invoking any of them repeatedly cycles backwards through the completion
list.</p><p>Note that one of the defaults is <code>&lt;S-TAB&gt;</code> which means Shift-TAB. That mapping
will probably only work in GUI Vim (Gvim or MacVim) and not in plain console Vim
because the terminal usually does not forward modifier key combinations to Vim.</p><p>Default: <code>['&lt;S-TAB&gt;', '&lt;Up&gt;']</code></p><pre><code class="viml">let g:ycm_key_list_previous_completion = ['&lt;S-TAB&gt;', '&lt;Up&gt;']
</code></pre><h3 id="the-gycm_key_invoke_completion-option">The <code>g:ycm_key_invoke_completion</code> option</h3><p>This option controls the key mapping used to invoke the completion menu for
semantic completion. By default, semantic completion is trigged automatically
after typing <code>.</code>, <code>-&gt;</code> and <code>::</code> in insert mode (if semantic completion support
has been compiled in). This key mapping can be used to trigger semantic
completion anywhere. Useful for searching for top-level functions and classes.</p><p>Console Vim (not Gvim or MacVim) passes <code>&lt;Nul&gt;</code> to Vim when the user types
<code>&lt;C-Space&gt;</code> so YCM will make sure that <code>&lt;Nul&gt;</code> is used in the map command when
you're editing in console Vim, and <code>&lt;C-Space&gt;</code> in GUI Vim. This means that you
can just press <code>&lt;C-Space&gt;</code> in both console and GUI Vim and YCM will do the right
thing.</p><p>Setting this option to an empty string will make sure no mapping is created.</p><p>Default: <code>&lt;C-Space&gt;</code></p><pre><code class="viml">let g:ycm_key_invoke_completion = '&lt;C-Space&gt;'
</code></pre><h3 id="the-gycm_key_detailed_diagnostics-option">The <code>g:ycm_key_detailed_diagnostics</code> option</h3><p>This option controls the key mapping used to show the full diagnostic text when
the user's cursor is on the line with the diagnostic. It basically calls
<code>:YcmShowDetailedDiagnostic</code>.</p><p>Setting this option to an empty string will make sure no mapping is created.</p><p>Default: <code>&lt;leader&gt;d</code></p><pre><code class="viml">let g:ycm_key_detailed_diagnostics = '&lt;leader&gt;d'
</code></pre><h3 id="the-gycm_global_ycm_extra_conf-option">The <code>g:ycm_global_ycm_extra_conf</code> option</h3><p>Normally, YCM searches for a <code>.ycm_extra_conf.py</code> file for compilation flags
(see the User Guide for more details on how this works). This option specifies
a fallback path to a config file which is used if no <code>.ycm_extra_conf.py</code> is
found.</p><p>You can place such a global file anywhere in your filesystem.</p><p>Default: <code>''</code></p><pre><code class="viml">let g:ycm_global_ycm_extra_conf = ''
</code></pre><h3 id="the-gycm_confirm_extra_conf-option">The <code>g:ycm_confirm_extra_conf</code> option</h3><p>When this option is set to <code>1</code> YCM will ask once per <code>.ycm_extra_conf.py</code> file
if it is safe to be loaded. This is to prevent execution of malicious code
from a <code>.ycm_extra_conf.py</code> file you didn't write.</p><p>To selectively get YCM to ask/not ask about loading certain <code>.ycm_extra_conf.py</code>
files, see the <code>g:ycm_extra_conf_globlist</code> option.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_confirm_extra_conf = 1
</code></pre><h3 id="the-gycm_extra_conf_globlist-option">The <code>g:ycm_extra_conf_globlist</code> option</h3><p>This option is a list that may contain several globbing patterns. If a pattern
starts with a <code>!</code> all <code>.ycm_extra_conf.py</code> files matching that pattern will be
blacklisted, that is they won't be loaded and no confirmation dialog will be
shown. If a pattern does not start with a <code>!</code> all files matching that pattern
will be whitelisted. Note that this option is not used when confirmation is
disabled using <code>g:ycm_confirm_extra_conf</code> and that items earlier in the list
will take precedence over the later ones.</p><p>Rules:</p><ul>
<li><code>*</code>       matches everything</li>
<li><code>?</code>       matches any single character</li>
<li><code>[seq]</code>   matches any character in seq</li>
<li><code>[!seq]</code>  matches any char not in seq</li>
</ul><p>Example:</p><pre><code class="viml">let g:ycm_extra_conf_globlist = ['~/dev/*','!~/*']
</code></pre><ul>
<li>The first rule will match everything contained in the <code>~/dev</code> directory so
  <code>.ycm_extra_conf.py</code> files from there will be loaded.</li>
<li>The second rule will match everything in the home directory so a
  <code>.ycm_extra_conf.py</code> file from there won't be loaded.</li>
<li>As the first rule takes precedence everything in the home directory excluding
  the <code>~/dev</code> directory will be blacklisted.</li>
</ul><p><strong>NOTE:</strong> The glob pattern is first expanded with Python's
<code>os.path.expanduser()</code> and then resolved with <code>os.path.abspath()</code> before being
matched against the filename.</p><p>Default: <code>[]</code></p><pre><code class="viml">let g:ycm_extra_conf_globlist = []
</code></pre><h3 id="the-gycm_filepath_completion_use_working_dir-option">The <code>g:ycm_filepath_completion_use_working_dir</code> option</h3><p>By default, YCM's filepath completion will interpret relative paths like <code>../</code>
as being relative to the folder of the file of the currently active buffer.
Setting this option will force YCM to always interpret relative paths as being
relative to Vim's current working directory.</p><p>Default: <code>0</code></p><pre><code class="viml">let g:ycm_filepath_completion_use_working_dir = 0
</code></pre><h3 id="the-gycm_semantic_triggers-option">The <code>g:ycm_semantic_triggers</code> option</h3><p>This option controls the character-based triggers for the various semantic
completion engines. The option holds a dictionary of key-values, where the keys
are Vim's filetype strings delimited by commas and values are lists of strings,
where the strings are the triggers.</p><p>Setting key-value pairs on the dictionary <em>adds</em> semantic triggers to the
internal default set (listed below). You cannot remove the default triggers,
only add new ones.</p><p>A "trigger" is a sequence of one or more characters that trigger semantic
completion when typed. For instance, C++ (<code>cpp</code> filetype) has <code>.</code> listed as a
trigger. So when the user types <code>foo.</code>, the semantic engine will trigger and
serve <code>foo</code>'s list of member functions and variables. Since C++ also has <code>-&gt;</code>
listed as a trigger, the same thing would happen when the user typed <code>foo-&gt;</code>.</p><p>It's also possible to use a regular expression as a trigger. You have to prefix
your trigger with <code>re!</code> to signify it's a regex trigger. For instance,
<code>re!\w+\.</code> would only trigger after the <code>\w+\.</code> regex matches.</p><p><strong>NOTE:</strong> The regex syntax is <strong>NOT</strong> Vim's, it's <a href="https://docs.python.org/2/library/re.html#regular-expression-syntax">Python's</a>.</p><p>Default: <code>[see next line]</code></p><pre><code class="viml">let g:ycm_semantic_triggers =  {
  \   'c' : ['-&gt;', '.'],
  \   'objc' : ['-&gt;', '.', 're!\[[_a-zA-Z]+\w*\s', 're!^\s*[^\W\d]\w*\s',
  \             're!\[.*\]\s'],
  \   'ocaml' : ['.', '#'],
  \   'cpp,objcpp' : ['-&gt;', '.', '::'],
  \   'perl' : ['-&gt;'],
  \   'php' : ['-&gt;', '::'],
  \   'cs,java,javascript,typescript,d,python,perl6,scala,vb,elixir,go' : ['.'],
  \   'ruby' : ['.', '::'],
  \   'lua' : ['.', ':'],
  \   'erlang' : [':'],
  \ }
</code></pre><h3 id="the-gycm_cache_omnifunc-option">The <code>g:ycm_cache_omnifunc</code> option</h3><p>Some omnicompletion engines do not work well with the YCM cacheâ€”in particular,
they might not produce all possible results for a given prefix. By unsetting
this option you can ensure that the omnicompletion engine is re-queried on every
keypress. That will ensure all completions will be presented, but might cause
stuttering and lagginess if the omnifunc is slow.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_cache_omnifunc = 1
</code></pre><h3 id="the-gycm_use_ultisnips_completer-option">The <code>g:ycm_use_ultisnips_completer</code> option</h3><p>By default, YCM will query the UltiSnips plugin for possible completions of
snippet triggers. This option can turn that behavior off.</p><p>Default: <code>1</code></p><pre><code class="viml">let g:ycm_use_ultisnips_completer = 1
</code></pre><h3 id="the-gycm_goto_buffer_command-option">The <code>g:ycm_goto_buffer_command</code> option</h3><p>Defines where <code>GoTo*</code> commands result should be opened.
Can take one of the following values:
<code>[ 'same-buffer', 'horizontal-split', 'vertical-split', 'new-tab',
  'new-or-existing-tab' ]</code>
If this option is set to the <code>'same-buffer'</code> but current buffer can not
be switched (when buffer is modified and <code>nohidden</code> option is set),
then result will be opened in horizontal split.</p><p>Default: <code>'same-buffer'</code></p><pre><code class="viml">let g:ycm_goto_buffer_command = 'same-buffer'
</code></pre><h3 id="the-gycm_disable_for_files_larger_than_kb-option">The <code>g:ycm_disable_for_files_larger_than_kb</code> option</h3><p>Defines the max size (in Kb) for a file to be considered for completion. If this
option is set to 0 then no check is made on the size of the file you're opening.</p><p>Default: 1000</p><pre><code class="viml">let g:ycm_disable_for_files_larger_than_kb = 1000
</code></pre><h3 id="the-gycm_python_binary_path-option">The <code>g:ycm_python_binary_path</code> option</h3><p>This option specifies the Python interpreter to use to run the <a href="https://github.com/davidhalter/jedi">jedi</a>
completion library.  Specify the Python interpreter to use to get completions.
By default the Python under which <a href="https://github.com/Valloric/ycmd">ycmd</a> runs is used (<a href="https://github.com/Valloric/ycmd">ycmd</a> runs on
Python 2.6, 2.7 or 3.3+).</p><p>Default: <code>''</code></p><pre><code class="viml">let g:ycm_python_binary_path = 'python'
</code></pre><p><strong>NOTE:</strong> the settings above will make YCM use the first <code>python</code> executable
found through the PATH.</p><h2 id="faq">FAQ</h2><h3 id="i-used-to-be-able-to-import-vim-in-ycm_extra_confpy-but-now-cant">I used to be able to <code>import vim</code> in <code>.ycm_extra_conf.py</code>, but now can't</h3><p>YCM was rewritten to use a client-server architecture where most of the logic is
in the <a href="https://github.com/Valloric/ycmd">ycmd server</a>. So the magic <code>vim</code> module you could have previously
imported in your <code>.ycm_extra_conf.py</code> files doesn't exist anymore.</p><p>To be fair, importing the magic <code>vim</code> module in extra conf files was never
supported in the first place; it only ever worked by accident and was never a
part of the extra conf API.</p><p>But fear not, you should be able to tweak your extra conf files to continue
working by using the <code>g:ycm_extra_conf_vim_data</code> option. See the docs on that
option for details.</p><h3 id="i-get-importerror-exceptions-that-mention-pyinit_ycm_core-or-initycm_core">I get <code>ImportError</code> exceptions that mention <code>PyInit_ycm_core</code> or <code>initycm_core</code></h3><p>These errors are caused by building the YCM native libraries for Python 2 and
trying to load them into a Python 3 process (or the other way around).</p><p>For instance, if building for Python 2 but loading in Python 3:</p><pre><code>ImportError: dynamic module does not define init function (PyInit_ycm_core)
</code></pre><p>If building for Python 3 but loading in Python 2:</p><pre><code>ImportError: dynamic module does not define init function (initycm_core)
</code></pre><p>Setting the <code>g:ycm_server_python_interpreter</code> option to force the use of a
specific Python interpreter for <code>ycmd</code> is usually the easiest way to solve the
problem. Common values for that option are <code>/usr/bin/python</code> and
<code>/usr/bin/python3</code>.</p><h3 id="i-get-a-linker-warning-regarding-libpython-on-mac-when-compiling-ycm">I get a linker warning regarding <code>libpython</code> on Mac when compiling YCM</h3><p>If the warning is <code>ld: warning: path '/usr/lib/libpython2.7.dylib' following -L
not a directory</code>, then feel free to ignore it; it's caused by a limitation of
CMake and is not an issue. Everything should still work fine.</p><h3 id="i-get-a-weird-window-at-the-top-of-my-file-when-i-use-the-semantic-engine">I get a weird window at the top of my file when I use the semantic engine</h3><p>This is Vim's <code>preview</code> window. Vim uses it to show you extra information about
something if such information is available. YCM provides Vim with such extra
information. For instance, when you select a function in the completion list,
the <code>preview</code> window will hold that function's prototype and the prototypes of
any overloads of the function. It will stay there after you select the
completion so that you can use the information about the parameters and their
types to write the function call.</p><p>If you would like this window to auto-close after you select a completion
string, set the <code>g:ycm_autoclose_preview_window_after_completion</code> option to <code>1</code>
in your <code>vimrc</code> file. Similarly, the <code>g:ycm_autoclose_preview_window_after_insertion</code>
option can be set to close the <code>preview</code> window after leaving insert mode.</p><p>If you don't want this window to ever show up, add <code>set completeopt-=preview</code> to
your <code>vimrc</code>. Also make sure that the <code>g:ycm_add_preview_to_completeopt</code> option
is set to <code>0</code>.</p><h3 id="it-appears-that-ycm-is-not-working">It appears that YCM is not working</h3><p>In Vim, run <code>:messages</code> and carefully read the output. YCM will echo messages to
the message log if it encounters problems. It's likely you misconfigured
something and YCM is complaining about it.</p><p>Also, you may want to run the <code>:YcmDebugInfo</code> command; it will make YCM spew out
various debugging information, including the YCM and <a href="https://github.com/Valloric/ycmd">ycmd</a> logfile paths and
the compile flags for the current file if the file is a C-family language file
and you have compiled in Clang support. Logfiles can be opened in the editor
using <a href="#the-ycmtogglelogs-command">the <code>:YcmToggleLogs</code> command</a>.</p><h3 id="sometimes-it-takes-much-longer-to-get-semantic-completions-than-normal">Sometimes it takes much longer to get semantic completions than normal</h3><p>This means that libclang (which YCM uses for C-family semantic completion)
failed to pre-compile your file's preamble. In other words, there was an error
compiling some of the source code you pulled in through your header files. I
suggest calling the <code>:YcmDiags</code> command to see what they were.</p><p>Bottom line, if libclang can't pre-compile your file's preamble because there
were errors in it, you're going to get slow completions because there's no AST
cache.</p><h3 id="ycm-auto-inserts-completion-strings-i-dont-want">YCM auto-inserts completion strings I don't want!</h3><p>This means you probably have some mappings that interfere with YCM's internal
ones. Make sure you don't have something mapped to <code>&lt;C-p&gt;</code>, <code>&lt;C-x&gt;</code> or <code>&lt;C-u&gt;</code>
(in insert mode).</p><p>YCM <em>never</em> selects something for you; it just shows you a menu and the user has
to explicitly select something. If something is being selected automatically,
this means there's a bug or a misconfiguration somewhere.</p><h3 id="i-get-a-e227-mapping-already-exists-for-blah-error-when-i-start-vim">I get a <code>E227: mapping already exists for &lt;blah&gt;</code> error when I start Vim</h3><p>This means that YCM tried to set up a key mapping but failed because you already
had something mapped to that key combination. The <code>&lt;blah&gt;</code> part of the message
will tell you what was the key combination that failed.</p><p>Look in the <em>Options</em> section and see if any of the default mappings conflict
with your own. Then change that option value to something else so that the
conflict goes away.</p><h3 id="i-get-glibc_2xx-not-found-required-by-libclangso-when-starting-vim">I get <code>'GLIBC_2.XX' not found (required by libclang.so)</code> when starting Vim</h3><p>Your system is too old for the precompiled binaries from llvm.org. Compile
Clang on your machine and then link against the <code>libclang.so</code> you just produced.
See the full installation guide for help.</p><h3 id="im-trying-to-use-a-homebrew-vim-with-ycm-and-im-getting-segfaults">I'm trying to use a Homebrew Vim with YCM and I'm getting segfaults</h3><p>Something (I don't know what) is wrong with the way that Homebrew configures and
builds Vim. I recommend using <a href="https://github.com/macvim-dev/macvim/releases">MacVim</a>. Even if you don't like the MacVim GUI,
you can use the Vim binary that is inside the MacVim.app package (it's
<code>MacVim.app/Contents/MacOS/Vim</code>) and get the Vim console experience.</p><h3 id="i-have-a-homebrew-python-andor-macvim-cant-compilesigabrt-when-starting">I have a Homebrew Python and/or MacVim; can't compile/SIGABRT when starting</h3><p>You should probably run <code>brew rm python; brew install python</code> to get the latest
fixes that should make YCM work with such a configuration. Also rebuild Macvim
then. If you still get problems with this, see <a href="https://github.com/Valloric/YouCompleteMe/issues/18">issue #18</a> for
suggestions.</p><h3 id="i-get-long_bit-definition-appears-wrong-for-platform-when-compiling">I get <code>LONG_BIT definition appears wrong for platform</code> when compiling</h3><p>Look at the output of your CMake call. There should be a line in it like the
following (with <code>.dylib</code> in place of <code>.so</code> on a Mac):</p><pre><code>-- Found PythonLibs: /usr/lib/libpython2.7.so (Required is at least version "2.5")
</code></pre><p>That would be the <strong>correct</strong> output. An example of <strong>incorrect</strong> output would
be the following:</p><pre><code>-- Found PythonLibs: /usr/lib/libpython2.7.so (found suitable version "2.5.1", minimum required is "2.5")
</code></pre><p>Notice how there's an extra bit of output there, the <code>found suitable version
"&lt;version&gt;"</code> part, where <code>&lt;version&gt;</code> is not the same as the version of the
dynamic library. In the example shown, the library is version 2.7 but the second
string is version <code>2.5.1</code>.</p><p>This means that CMake found one version of Python headers and a different
version for the library. This is wrong. It can happen when you have multiple
versions of Python installed on your machine.</p><p>You should probably add the following flags to your cmake call (again, <code>dylib</code>
instead of <code>so</code> on a Mac):</p><pre><code>-DPYTHON_INCLUDE_DIR=/usr/include/python2.7 -DPYTHON_LIBRARY=/usr/lib/libpython2.7.so
</code></pre><p>This will force the paths to the Python include directory and the Python library
to use. You may need to set these flags to something else, but you need to make
sure you use the same version of Python that your Vim binary is built against,
which is highly likely to be the system's default Python.</p><h3 id="i-get-libpython27a--relocation-r_x86_64_32-when-compiling">I get <code>libpython2.7.a [...] relocation R_X86_64_32</code> when compiling</h3><p>The error is usually encountered when compiling YCM on Centos or RHEL. The full
error looks something like the following:</p><pre><code>/usr/bin/ld: /usr/local/lib/libpython2.7.a(abstract.o): relocation R_X86_64_32 against `a local symbol' can not be used when making a shared object; recompile with -fPIC
</code></pre><p>It's possible to get a slightly different error that's similar to the one above.
Here's the problem and how you solve it:</p><p>Your <code>libpython2.7.a</code> was not compiled with <code>-fPIC</code> so it can't be linked into
<code>ycm_core.so</code>.  Use the <code>-DPYTHON_LIBRARY=</code> CMake flag to point it to a <code>.so</code>
version of libpython on your machine (for instance,
<code>-DPYTHON_LIBRARY=/usr/lib/libpython2.7.so</code>). Naturally, this means you'll have
to go through the full installation guide by hand.</p><h3 id="i-get-vim-caught-deadly-signal-segv-on-vim-startup">I get <code>Vim: Caught deadly signal SEGV</code> on Vim startup</h3><p>This can happen on some Linux distros. If you encounter this situation, run Vim
under <code>gdb</code>. You'll probably see something like this in the output when Vim
crashes:</p><pre><code>undefined symbol: clang_CompileCommands_dispose
</code></pre><p>This means that Vim is trying to load a <code>libclang.so</code> that is too old. You need
at least a 3.9 libclang. Just go through the installation guide and make sure
you are using a correct <code>libclang.so</code>. We recommend downloading prebuilt
binaries from llvm.org.</p><h3 id="i-get-fatal-python-error-pythreadstate_get-no-current-thread-on-startup">I get <code>Fatal Python error: PyThreadState_Get: no current thread</code> on startup</h3><p>This is caused by linking a static version of <code>libpython</code> into ycmd's
<code>ycm_core.so</code>.  This leads to multiple copies of the python interpreter loaded
when <code>python</code> loads <code>ycmd_core.so</code> and this messes up python's global state.
The details aren't important.</p><p>The solution is that the version of Python linked and run against must be built
with either <code>--enable-shared</code> or <code>--enable-framework</code> (on OS X).
This is achieved as follows (<strong>NOTE:</strong> for Mac, replace <code>--enable-shared</code>
with <code>--enable-framework</code>):</p><ul>
<li>When building python from source: <code>./configure --enable-shared {options}</code></li>
<li>When building python from pyenv:
  <code>PYTHON_CONFIGURE_OPTS="--enable-shared" pyenv install {version}</code></li>
</ul><h3 id="installpy-says-python-must-be-compiled-with---enable-framework-wat"><code>install.py</code> says python must be compiled with <code>--enable-framework</code>. Wat?</h3><p>See the previous answer for how to ensure your python is built to support
dynamic modules.</p><h3 id="ycm-does-not-read-identifiers-from-my-tags-files">YCM does not read identifiers from my tags files</h3><p>First, put <code>let g:ycm_collect_identifiers_from_tags_files = 1</code> in your vimrc.</p><p>Make sure you are using <a href="http://ctags.sourceforge.net/">Exuberant Ctags</a> to produce your tags
files since the only supported tag format is the <a href="http://ctags.sourceforge.net/FORMAT">Exuberant Ctags
format</a>. The format from "plain" ctags is NOT supported. The
output of <code>ctags --version</code> should list "Exuberant Ctags".</p><p>Ctags needs to be called with the <code>--fields=+l</code> (that's a lowercase <code>L</code>, not a
one) option because YCM needs the <code>language:&lt;lang&gt;</code> field in the tags output.</p><p><strong>NOTE:</strong> <a href="http://ctags.sourceforge.net/">Exuberant Ctags</a> by default sets language tag for
<code>*.h</code> files as <code>C++</code>. If you have C (not C++) project, consider giving parameter
<code>--langmap=c:.c.h</code> to ctags to see tags from <code>*.h</code> files.</p><p><strong>NOTE:</strong> Mac OS X comes with "plain" ctags installed by default. <code>brew install
ctags</code> will get you the Exuberant Ctags version.</p><p>Also make sure that your Vim <code>tags</code> option is set correctly. See <code>:h 'tags'</code> for
details. If you want to see which tag files YCM will read for a given buffer,
run <code>:echo tagfiles()</code> with the relevant buffer active. Note that that function
will only list tag files that already exist.</p><h3 id="ctrl-u-in-insert-mode-does-not-work"><code>CTRL-U</code> in insert mode does not work</h3><p>YCM keeps you in a <code>completefunc</code> completion mode when you're typing in insert
mode and Vim disables <code>&lt;C-U&gt;</code> in completion mode as a "feature." Sadly there's
nothing I can do about this.</p><h3 id="ycm-conflicts-with-ultisnips-tab-key-usage">YCM conflicts with UltiSnips TAB key usage</h3><p>YCM comes with support for UltiSnips (snippet suggestions in the popup menu),
but you'll have to change the UltiSnips mappings. See <code>:h UltiSnips-triggers</code> in
Vim for details. You'll probably want to change some/all of the following
options:</p><pre><code class="viml">g:UltiSnipsExpandTrigger
g:UltiSnipsJumpForwardTrigger
g:UltiSnipsJumpBackwardTrigger
</code></pre><h3 id="snippets-added-with-ultisnipsaddfiletypes-do-not-appear-in-the-popup-menu">Snippets added with <code>:UltiSnipsAddFiletypes</code> do not appear in the popup menu</h3><p>For efficiency, YCM only fetches UltiSnips snippets in specific scenarios like
visiting a buffer or setting its filetype. You can force YCM to retrieve them by
manually triggering the <code>FileType</code> autocommand:</p><pre><code class="viml">:doautocmd FileType
</code></pre><h3 id="why-isnt-ycm-just-written-in-plain-vimscript-ffs">Why isn't YCM just written in plain VimScript, FFS?</h3><p>Because of the identifier completion engine and subsequence-based filtering.
Let's say you have <em>many</em> dozens of files open in a single Vim instance (I often
do); the identifier-based engine then needs to store thousands (if not tens of
thousands) of identifiers in its internal data-structures. When the user types,
YCM needs to perform subsequence-based filtering on <em>all</em> of those identifiers
(every single one!) in less than 10 milliseconds.</p><p>I'm sorry, but that level of performance is just plain impossible to achieve
with VimScript. I've tried, and the language is just too slow. No, you can't get
acceptable performance even if you limit yourself to just the identifiers in the
current file and simple prefix-based filtering.</p><h3 id="why-does-ycm-demand-such-a-recent-version-of-vim">Why does YCM demand such a recent version of Vim?</h3><p>During YCM's development several show-stopper bugs were encountered in Vim.
Those needed to be fixed upstream (and were). A few months after those bugs were
fixed, Vim trunk landed the <code>pyeval()</code> function which improved YCM performance
even more since less time was spent serializing and deserializing data between
Vim and the embedded Python interpreter. A few critical bugfixes for <code>pyeval()</code>
landed in Vim 7.3.584 (and a few commits before that), and given the current
availability of Vim 7.4.143, which features improved events for text change
detection, it has been chosen.</p><h3 id="i-get-annoying-messages-in-vims-status-area-when-i-type">I get annoying messages in Vim's status area when I type</h3><p>If you're referring to the <code>User defined completion &lt;bla bla&gt; back at original</code>
and similar, then just update to Vim 7.4.314 (or later) and they'll go away.</p><h3 id="nasty-bugs-happen-if-i-have-the-vim-autoclose-plugin-installed">Nasty bugs happen if I have the <code>vim-autoclose</code> plugin installed</h3><p>Use the <a href="https://github.com/Raimondi/delimitMate">delimitMate</a> plugin instead. It does the same thing without
conflicting with YCM.</p><h3 id="is-there-some-sort-of-ycm-mailing-list-i-have-questions">Is there some sort of YCM mailing list? I have questions</h3><p>If you have questions about the plugin or need help, please use the
<a href="https://groups.google.com/forum/?hl=en#!forum/ycm-users">ycm-users</a> mailing list, <em>don't</em> create issues on the tracker. The tracker is
for bug reports and feature requests.</p><h3 id="i-get-an-internal-compiler-error-when-installing">I get an internal compiler error when installing</h3><p>This can be a problem on virtual servers with limited memory. A possible
solution is to add more swap memory. A more practical solution would be to force
the build script to run only one compile job at a time. You can do this by
setting the <code>YCM_CORES</code> environment variable to <code>1</code>. Example:</p><pre><code>YCM_CORES=1 ./install.py --clang-completer
</code></pre><h3 id="i-get-weird-errors-when-i-press-ctrl-c-in-vim">I get weird errors when I press <code>Ctrl-C</code> in Vim</h3><p><em>Never</em> use <code>Ctrl-C</code> in Vim.</p><p>Using <code>Ctrl-C</code> to exit insert mode in Vim is a bad idea. The main issue here is
that <code>Ctrl-C</code> in Vim doesn't just leave insert mode, it leaves it without
triggering <code>InsertLeave</code> autocommands (as per Vim docs). This is a bad idea and
is likely to break many other things and not just YCM.</p><p>Bottom line, if you use <code>Ctrl-C</code> to exit insert mode in Vim, you're gonna have a
bad time.</p><p>If pressing <code>&lt;esc&gt;</code> is too annoying (agreed, it is), we suggest mapping it to
something more convenient. On a QWERTY keyboard, a good pick for the <code>&lt;esc&gt;</code> map
is <code>inoremap jk &lt;Esc&gt;</code>. This is right on the home row, it's an incredibly rare
digraph in English and if you ever need to type those two chars in sequence in
insert mode, you just type <code>j</code>, then wait 500ms, then type <code>k</code>.</p><h3 id="why-did-ycm-stop-using-syntastic-for-diagnostics-display">Why did YCM stop using Syntastic for diagnostics display?</h3><p>Previously, YCM would send any diagnostics it would receive from the libclang
semantic engine to Syntastic for display as signs in the gutter, red squiggles
etc. Today, YCM uses its own code to do that.</p><p>Using Syntastic for this was always a kludge. Syntastic assumes its "checker"
plugins behave in a certain way; those assumptions have never fit YCM. For
instance, YCM continuously recompiles your code in the background for C-family
languages and tries to push new diagnostics to the user as fast as possible,
even while the user types.</p><p>Syntastic assumes that a checker only runs on file save ("active" mode) or even
less frequently, when the user explicitly invokes it ("passive" mode). This
mismatch in assumptions causes performance problems since Syntastic code isn't
optimized for this use case of constant diagnostic refreshing.</p><p>Poor support for this use case also led to crash bugs in Vim caused by
Syntastic-Vim interactions (<a href="https://github.com/Valloric/YouCompleteMe/issues/593">issue #593</a>) and other problems, like
random Vim flickering. Attempts were made to resolve these issues in
Syntastic, but ultimately some of them failed (for various reasons).</p><p>Implementing diagnostic display code directly in YCM resolves all of these
problems. Performance also improved substantially since the relevant code is now
written in Python instead of VimScript (which is very slow) and is tailored only
for YCM's use-cases. We were also able to introduce new features in this area
since we're now not limited to the Syntastic checker API.</p><p>We've tried to implement this in the most backwards-compatible way possible; YCM
options that control diagnostic display fall back to Syntastic options that
control the same concepts if the user has those set.</p><p>Still, some Syntastic-specific configuration you might have had might not
be supported by the new code. Please file issues on the tracker in such
cases; if we find the request to be reasonable, we'll find a way to address it.</p><h3 id="completion-doesnt-work-with-the-c-standard-library-headers">Completion doesn't work with the C++ standard library headers</h3><p>This is caused by an issue with libclang that only affects some operating
systems. Compiling with <code>clang</code> the binary will use the correct default header
search paths but compiling with <code>libclang.so</code> (which YCM uses) does not.</p><p>Mac OS X is normally affected, but there's a workaround in YCM for that specific
OS. If you're not running that OS but still have the same problem, continue
reading.</p><p>The workaround is to call <code>echo | clang -v -E -x c++ -</code> and look at the
paths under the <code>#include &lt;...&gt; search starts here:</code> heading. You should take
those paths, prepend <code>-isystem</code> to each individual path and append them all to
the list of flags you return from your <code>FlagsForFile</code> function in your
<code>.ycm_extra_conf.py</code> file.</p><p>See <a href="https://github.com/Valloric/YouCompleteMe/issues/303">issue #303</a> for details.</p><h3 id="when-i-open-a-javascript-file-i-get-an-annoying-warning-about-tern-project-file">When I open a JavaScript file, I get an annoying warning about <code>.tern-project</code> file</h3><p>Take a look at the <a href="#javascript-semantic-completion">instructions for using the JavaScript
completer</a>.</p><p>If this is still really annoying, and you have a good reason not to have a
<code>.tern-project</code> file, create an empty <code>.tern-config</code> file in your home directory
and YCM will stop complaining.</p><h3 id="when-i-start-vim-i-get-a-runtime-error-saying-r6034-an-application-has-made-an-attempt-to-load-the-c-runtime-library-incorrectly">When I start vim I get a runtime error saying <code>R6034 An application has made an attempt to load the C runtime library incorrectly.</code></h3><p><a href="http://stackoverflow.com/questions/14552348/runtime-error-r6034-in-embedded-python-application/34696022">CMake and other things seem to screw up the PATH with their own msvcrXX.dll
versions.</a> Add the following to the very top of your vimrc
to remove these entries from the path.</p><pre><code class="python">python &lt;&lt; EOF
import os
import re
path = os.environ['PATH'].split(';')

def contains_msvcr_lib(folder):
    try:
        for item in os.listdir(folder):
            if re.match(r'msvcr\d+\.dll', item):
                return True
    except:
        pass
    return False

path = [folder for folder in path if not contains_msvcr_lib(folder)]
os.environ['PATH'] = ';'.join(path)
EOF
</code></pre><h3 id="i-hear-that-ycm-only-supports-python-2-is-that-true">I hear that YCM only supports Python 2, is that true?</h3><p><strong>No.</strong> Both the Vim client and the <a href="https://github.com/Valloric/ycmd">ycmd server</a> run on Python 2 or 3. If
you work on a Python 3 project, you may need to set <code>g:ycm_python_binary_path</code>
to the Python interpreter you use for your project to get completions for that
version of Python.</p><h3 id="on-windows-i-get-e887-sorry-this-command-is-disabled-the-pythons-site-module-could-not-be-loaded">On Windows I get <code>E887: Sorry, this command is disabled, the Python's site module could not be loaded</code></h3><p>If you are running vim on Windows with Python 2.7.11, this is likely caused by a
<a href="https://github.com/vim/vim/issues/717">bug</a>. Follow this
<a href="https://github.com/vim/vim-win32-installer/blob/a27bbdba9bb87fa0e44c8a00d33d46be936822dd/appveyor.bat#L86-L88">workaround</a> or use a different version
(Python 2.7.12 does not suffer from the bug).</p><h3 id="i-cant-complete-python-packages-in-a-virtual-environment">I can't complete python packages in a virtual environment.</h3><p>This means that the Python used to run <a href="https://github.com/vheon/JediHTTP">JediHTTP</a> is not the Python of the
virtual environment you're in. To resolve this you either set
<code>g:ycm_python_binary_path</code> to the absolute path of the Python binary in your
virtual environment or since virtual environment will put that Python
executable first in your PATH when the virtual environment is active then if
you set <code>g:ycm_python_binary_path</code> to just <code>'python'</code> it will be found as the
first Python and used to run <a href="https://github.com/vheon/JediHTTP">JediHTTP</a>.</p><h3 id="i-want-to-defer-loading-of-youcompleteme-until-after-vim-finishes-booting">I want to defer loading of YouCompleteMe until after Vim finishes booting</h3><p>In recent versions of Vim, you can install YCM in a folder under
<code>~/.vim/pack/*/opt</code> and then load it once the user is idle via an autocommand:</p><pre><code class="viml">augroup load_ycm
  autocmd!
  autocmd CursorHold, CursorHoldI * :packadd YouCompleteMe
                                \ | autocmd! load_ycm
augroup END
</code></pre><h2 id="contributor-code-of-conduct">Contributor Code of Conduct</h2><p>Please note that this project is released with a <a href="https://github.com/Valloric/YouCompleteMe/blob/master/CODE_OF_CONDUCT.md">Contributor Code of
Conduct</a>. By participating in this project you agree to abide by its
terms.</p><h2 id="contact">Contact</h2><p>If you have questions about the plugin or need help, please join the <a href="https://gitter.im/Valloric/YouCompleteMe">Gitter
room</a> or use the <a href="https://groups.google.com/forum/?hl=en#!forum/ycm-users">ycm-users</a> mailing list.</p><p>If you have bug reports or feature suggestions, please use the <a href="https://github.com/Valloric/YouCompleteMe/issues?state=open">issue
tracker</a>.</p><p>The latest version of the plugin is available at
<a href="http://valloric.github.io/YouCompleteMe/">http://valloric.github.io/YouCompleteMe/</a>.</p><p>The author's homepage is <a href="http://val.markovic.io">http://val.markovic.io</a>.</p><h2 id="license">License</h2><p>This software is licensed under the <a href="http://www.gnu.org/copyleft/gpl.html">GPL v3 license</a>.
Â© 2015-2017 YouCompleteMe contributors</p></div>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-34688172-3");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
    <a href="https://github.com/Valloric/YouCompleteMe"><img alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" style="position: absolute; top: 0; right: 0; border: 0;"/></a>

</body></html>